SPEC 2

(*
   RDL for C programs
*)

GROUP #External($1) {
    TEMPLATE #placeholder(...):$1,

    /\(\(w\|_w\)?getenv\|getc\)/(...):$1,
    RegQueryValueEx(...,$1,$$),
    cin(..., $1, ...),
    [fgets,fread,fgetws]($1,...),
    fscanf($<NAME stdin>, $$, ..., $1, ...),
    read($$, $1,...),
    scanf($$, ..., $1, ...),
    $1<EXTERN>
}

GROUP #StrMoveFunc($1, $2) {
    TEMPLATE #placeholder($1, ..., $2, ...),

    /_?snw?printf/($1, $$, $$, ..., $2, ...),
    [sprintf,wsprintf]($1, $$, ..., $2, ...),
    [strcat,strcpy,wcscpy]($1, $2),
    [strncat,wcsncat,strncpy]($1, $2, $$),
    sscanf($2, $$, ..., $1, ...)
}

GROUP #ReadFromStdin() {
    TEMPLATE #placeholder(...),

    cin(...),
    [fgets,fread,fgetws](..., $<NAME stdin>),
    fscanf($<NAME stdin>, ...),
    [scanf,gets](...)
}

GROUP #StrCmpFunc($1) {
    TEMPLATE #placeholder(..., $1, ...),

    [strcmp,strstr,strncmp]($$, $1, ...),
    [strcmp,strstr,strncmp]($1, $$, ...)
}

GROUP #StrCmp($1, $2) {
    TEMPLATE #placeholder($1, ..., $2, ...),

    [strcmp,strstr,strncmp]($1, $2, ...)
}

GROUP #StrExam($1) {
    TEMPLATE #placeholder(..., $1, ...),

    [strchr,strcspn,strpbrk,strrchr,strspn,strstr]($1,...)
}

GROUP #LDAPfunction($1, $2) {
    TEMPLATE #placeholder($1, ..., $2, ...),

    // $1 = the DN of the entry at which to start the search.
    // $2 = a string representation of the filter to apply in the search.
    /ldap_search\(_ext\|_ext_s\|_ext_sA\|_ext_sW\|_s\|_st\)?/($$, $1, $$, $2, ...)
}

GROUP #StrDangerousReadFunc($1) {
    TEMPLATE #placeholder(..., $1, ...),

    [strcat,strcpy,strcmp]($$, $1),
    [strcmp,strlen]($1, ...)
}

GROUP #LDFunc($1) {
    TEMPLATE #placeholder(..., $1, ...),

    dlsym($$,$1),
    /\(LoadLibrary[AW]?\|dlopen\)/($1, ...)
}

GROUP #UnsignedAllocFunc($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(calloc\|malloc\|newArray\)/($1, ...),
    realloc($$,$1)
}

GROUP #DBCon($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(OCILogon2?\|SQLConnect\)/($$, $$, $$, $$, $$, $1, ...),
    mysql_real_connect($$, $$, $$, $1, ...),
    createConnection($$, $1, ...)
}

GROUP #FileRead($1) {
    TEMPLATE #placeholder(..., $1, ...),

    [fgets,fread]($1, ...),
    read($$, $1, ...)
}

GROUP #SetID() {
    TEMPLATE #placeholder(),

    /set\(e\|fs\|re\|res\)?[gu]id/(...)
}

GROUP #WeakTempFunc() {
    TEMPLATE #placeholder(),

    {{GetTempFileName
\|_mktemp
\|_tempnam
\|_tmpfile
\|_tmpname
\|mktemp
\|tempnam
\|tmpfile
\|tmpnam
\|tmpnam_r}}(...)
}

GROUP #Alloc() {
    TEMPLATE #placeholder(),

    /\(calloc\|malloc\|realloc\)/(...)
}

GROUP #CONNECT($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(connect\|listen\)/($1, ...)
}

GROUP #RECV($1, $2) {
    TEMPLATE #placeholder($1, ..., $2, ...),

    /recv\(_rv\)?/($1, $2, ...)
}

GROUP #UseFile($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(CreateFile[AW]\|\(f\|fre\|_\|_wf\|w\|_w\)?open\|rename\|mkdir\|link\|lstat\|mknod\|symlink\|utime\|chown\|stat\|chmod\)/($1, ...),
    /\(remove\|unlink\|opendir\|rmdir\|unlink\)/($1),
    /\(rename\|link\|symlink\)/(..., $1)
}

GROUP #Res($1) {
    TEMPLATE #placeholder(..., $1, ...),

    connect($$, $1, ...),
    getenv($1, ...)
}


GROUP #PthreadMutexLock($1) {
    TEMPLATE #placeholder(..., $1, ...),

    [pthread_mutex_lock,pthread_mutex_trylock]($1)
}

GROUP #PthreadMutexUnlock($1) {
    TEMPLATE #placeholder(..., $1, ...),

    pthread_mutex_unlock($1)
}

// Unused yet.
// GROUP #StdThreadsMutexLock($1) {
//     TEMPLATE #placeholder(..., $1, ...),
//
//     mtx_lock($1)
// }

// Unused yet.
// GROUP #StdThreadsMutexUnlock($1) {
//     TEMPLATE #placeholder(..., $1, ...),
//
//     mtx_unlock($1)
// }

GROUP #MutexLock($1) {
    TEMPLATE #placeholder(..., $1, ...),

    [pthread_mutex_lock,pthread_mutex_trylock,mtx_lock]($1)
}

GROUP #MutexUnlock($1) {
    TEMPLATE #placeholder(..., $1, ...),

    [pthread_mutex_unlock,mtx_unlock]($1)
}

//////////////////////////////////////////////////////////////////////////////
// CWE-15 External Control of System or Configuration Setting

GROUP #Setting($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(sethostid\|SetComputerNameA\)/($1)
}

GROUP #"51000015".source = #External
GROUP #"51000015".sink = #Setting

RULE "51000015" {
    PATTERN {
        UNSAFE [#_.source($1)] <--if [#_.sink($1)]
    }

    PATTERN {
        UNSAFE [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
         <--if [#RECV($1, $2)] <--if [#_.sink($2)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-22 Path Traversal

GROUP #"51000022".source = #External

GROUP #"51000022".sink($1) {
    TEMPLATE #placeholder(..., $1, ...),

    #UseFile, #Res
}

RULE "51000022" {
    PATTERN {
        UNSAFE [#_.source($1)] <--if [#_.sink($1)]
    }

    PATTERN {
        UNSAFE [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
         <--if [#RECV($1, $2)] <--if [#_.sink($2)]
    }

    PATTERN {
        UNSAFE [#_.source($1)] <--if [ASSIGN($2<NAME sin_port> := $1)]
         <--if [#_.sink($2)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-41 Improper Resolution of Path Equivalence

GROUP #Canonicalize($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(realpath\|canonicalize_file_name\)/($1,...)
}

GROUP #"51000041".source = #External
GROUP #"51000041".compare = #StrCmpFunc
GROUP #"51000041".use = #UseFile
GROUP #"51000041".canon = #Canonicalize

RULE "51000041" {
    UNSAFE  AND[[#_.source($1)] <--if [#_.compare($1)];
                [#_.compare($1)] -->if [#_.use($1)]]
    EXCLUDE [#_.canon($$)] <==if [#_.compare($0)]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-78 Improper Neutralization of Special Elements used in an OS Command

GROUP #C_EXE($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(\(_w\)?system\|_?w?popen\)/($1, ...),
    /_?w?exec[lv]p?/(..., $1, ...),
    /_w?spawnvp?/($$, $1, ...),
    /\(_w?spawnlp?\|_spawnvl\)/($$, ..., $1, ...),
    /_w?spawnvp?/($$, $$, $1, ...)
}

GROUP #"51000078".source = #External
GROUP #"51000078".sink = #C_EXE

RULE "51000078" {
    PATTERN {
        UNSAFE  [#_.source($1)] <--if [#_.sink($1)]
        EXCLUDE [#_.source($1)] <==if [#StrExam($1)] <==if [#_.sink($1)]
    }

    PATTERN {
        UNSAFE [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
         <--if [#RECV($1, $2)] <--if [#_.sink($2)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-80 Improper Neutralization of Script-Related HTML Tags in a Web Page

GROUP #CGI_Input($1) {
    TEMPLATE #placeholder(...),

    /cgiFormString\(NoNewLines\|Multiple\)?/($$, $1, ...)
}

GROUP #CGI_Output($1) {
    TEMPLATE #placeholder(..., $1, ...),

    fprintf($<NAME cgiOut>, $$, $1),
    /* /\(printf\|putchar\|fputs\)/($1, ...), */
    /* printf($$, $1), */
    cgiHeaderCookieSetString($1, ...),
    cgiHeaderCookieSetString($$, $1, ...)
}

GROUP #"51000080".source($1) {
    TEMPLATE #placeholder(..., $1, ...),

    #CGI_Input, #External
}

GROUP #"51000080".sink = #CGI_Output

RULE "51000080" {
    PATTERN {
        UNSAFE [#_.source($1)] <--if [#_.sink($1)]
    }

    PATTERN {
        UNSAFE [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
          <--if [#RECV($1, $2)] <--if [#_.sink($2)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-89 Improper Neutralization of Special Elements used in an SQL Command

GROUP #SQLFunc($1) {
    TEMPLATE #placeholder(..., $1, ...),

    ExecuteSQL($1),
    /\(mysql_query\|PQexec\|SQLExecDirect\|sqlite3_exec\)/($$, $1, ...)
}

GROUP #"51000089".source = #External
GROUP #"51000089".sink = #SQLFunc

RULE "51000089" {
    PATTERN {
        UNSAFE [#_.source($1)] <--if [#_.sink($1)]
    }

    PATTERN {
        UNSAFE [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
         <--if [#RECV($1, $2)] <--if [#_.sink($2)]
    }

    PATTERN {
        UNSAFE [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
         <--if [#RECV($1, $2)] <--if [OCIStmtPrepare($3, $$, $2, ...)]
         <--if [OCIStmtExecute($$, $3, ...)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-90 Improper Neutralization of Special Elements used in an LDAP Query

GROUP #"51000090".source = #External
GROUP #"51000090".sink = #LDAPfunction

RULE "51000090" {
    PATTERN {
        UNSAFE [#_.source($1)] <--if [#_.sink($$, $1)]
    }

    PATTERN {
        UNSAFE [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
          <--if [#RECV($1, $2)] <--if [#_.sink($$,  $2)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-113 Improper Neutralization of CRLF Sequences in HTTP Headers

GROUP #CGI_HeaderLocation($1) {
    TEMPLATE #placeholder(..., $1, ...),

    cgiHeaderLocation($1)
}

GROUP #"51000113".source = #CGI_Input
GROUP #"51000113".sink = #CGI_HeaderLocation

RULE "51000113" {
    UNSAFE [#_.source($1)] <--if [#_.sink($1)]
}


//////////////////////////////////////////////////////////////////////////////
// CWE-114 Process Control

GROUP #"51000114".source = #External
GROUP #"51000114".sink = #LDFunc

RULE "51000114" {
    PATTERN {
        UNSAFE [#_.source($1)] <--if [#_.sink($1)]
    }

    PATTERN {
        UNSAFE [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
          <--if [#RECV($1, $2)] <--if [#_.sink($2)]
    }

    PATTERN {
        UNSAFE  [$1<STRING>] //@pragma(allow_vague)
          <--rf [#StrMoveFunc($2, $1)] <--rf [#_.sink($2)]
        EXCLUDE [#StrMoveFunc($1, $<LIT {\(/\|[A-Za-z]:\).*}>)] <--rf [#_.sink($1)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-117 Improper Output Neutralization for Logs

GROUP #SysLog($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(NSLog\|syslog\)/($$,$$,...,$1,...)
}

GROUP #"51000117".source = #External
GROUP #"51000117".sink = #SysLog

RULE "51000117" {
    PATTERN {
        UNSAFE [#_.source($1)] <--if [#_.sink($1)]
    }

    PATTERN {
        UNSAFE [$2<EXTERN>] <--if [#StrMoveFunc($1,$2)] <--rf [#_.sink($1)]
    }
}

// RULEID "51000120"
// UNSAFE VSP[SASP, C,119]

// RULE "51000121" {
//     PATTERN {
//         UNSAFE VSP[SASP, C,121]
//     }
// }

// RULE "51000122" {
//     PATTERN {
//         UNSAFE VSP[SASP, C,122]
//     }
// }

// RULEID "51000122"
// UNSAFE VSP[SASP, C,122]

// RULE "51000124" {
//      PATTERN {
//          UNSAFE VSP[SASP, C,124]
//      }
//  }

// RULEID "51000125"
// UNSAFE VSP[SASP, C,125]

// RULEID "51000129"
// UNSAFE VSP[SASP, C,129]

//////////////////////////////////////////////////////////////////////////////
// CWE-134 Uncontrolled Format String

GROUP #FormatFunc($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\([wv]?printf\|vwprintf\|v?scanf\)/($1,...),
    /\(\(f\|s\|vf\|vfw\|vs\|fw\)printf\|\(f\|s\|vf\|vs\)scanf\|syslog\(_r\)?\)/($$,$1,...),
    /\(\(cb\|sn\|_sn\|snw\|_snw\|vcb\|vsn\|sw\|vsw\)printf\|v?snscanf\|printf_xy\)/($$,$$,$1,...),
    /v?cbscanf/($$,$$,$$,$1,...)
}

GROUP #"51000134".source = #External
GROUP #"51000134".sink = #FormatFunc

RULE "51000134" {
    PATTERN {
        UNSAFE [#_.source($1)] <--if [#_.sink($1)]
    }

    PATTERN {
        UNSAFE [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
          <--if [#RECV($1, $2)] <--if [#_.sink($2)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-170 Improper Null Termination

GROUP #ReadFunc($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /read\(link\)?/($$,$1,...)
}

GROUP #"51000170".source = #ReadFunc
GROUP #"51000170".sink = #StrDangerousReadFunc

RULE "51000170" {
    UNSAFE [#_.source($1)] <--if [#_.sink($1)]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-190 Integer Overflow or Wraparound

IF !(product == "beSOURCE") THEN
GROUP #"51000190".source = #External

GROUP #"51000190".sanitizer($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51000190" {
    PATTERN {
        UNSAFE  [#_.source($1)] <--if [$1] in ARRAYINDEX
        EXCLUDE [#_.source($1)] <--if [$1] in IFCOND <--if [$1] in ARRAYINDEX
        EXCLUDE [#_.source($1)] <--if [$1] in LOOPCOND <--if [$1] in ARRAYINDEX
        EXCLUDE [#_.source($1)] <--if [#_.sanitizer($1)] <--if [$0] in ARRAYINDEX
    }

    PATTERN {
        UNSAFE  [#UnsignedAllocFunc($<SIGNED>)]
        EXCLUDE [#UnsignedAllocFunc($<CONSTANT>)]
        EXCLUDE [$1<INT OR CHAR>] in IFCOND
          <--rf [#UnsignedAllocFunc($1<SIGNED, NOT CONSTANT>)]
        EXCLUDE [$1<INT OR CHAR>] in LOOPCOND
          <--rf [#UnsignedAllocFunc($1<SIGNED, NOT CONSTANT>)]
        EXCLUDE AND[[fgets($1, $<CONSTANT>, $$)]
                     <--if [#UnsignedAllocFunc($1<SIGNED>)];
                    [$1<SIGNED, CONSTANT>] //@pragma(allow_vague)
          <--if [#UnsignedAllocFunc($1<SIGNED, NOT CONSTANT>)]]
        EXCLUDE [#_.sanitizer($$)]
          <--if [#UnsignedAllocFunc($0<SIGNED, NOT CONSTANT>)]
    }

    PATTERN {
        UNSAFE  [#_.source($1)]
          <--if [($1<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [($<INT OR CHAR, BOUNDED[-10000, 10000]>, +, $<INT OR CHAR, BOUNDED[-10000, 10000]>)]
        EXCLUDE [($1, _<, $$)] //@pragma(allow_vague)
          <--rf [($1<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [#_.source($1)]
          <--if [#_.sanitizer($1)]
          <--if [($1<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
    }

    PATTERN {
        UNSAFE  [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
          <--if [#RECV($1, $2)]
          <--if [($2<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [($<INT OR CHAR, BOUNDED[-10000, 10000]>, +, $<INT OR CHAR, BOUNDED[-10000, 10000]>)]
        EXCLUDE [($1, _<, $$)] //@pragma(allow_vague)
          <--if [($1<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
    }

    PATTERN {
        UNSAFE  [#_.source($1)]
          <--if [($1<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [($<INT OR CHAR, BOUNDED[-100, 100]>, *, $<INT OR CHAR, BOUNDED[-100, 100]>)]
        EXCLUDE [($1, _<, $$)] //@pragma(allow_vague)
          <--if [($1<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [#_.source($1)]
          <--if [#_.sanitizer($1)]
          <--if [($1<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
    }

    PATTERN {
        UNSAFE  [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
          <--if [#RECV($1, $2)]
          <--if [($2<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [($<INT OR CHAR, BOUNDED[-100, 100]>, *, $<INT OR CHAR, BOUNDED[-100, 100]>)]
        EXCLUDE [($1, _<, $$)] //@pragma(allow_vague)
          <--if [($1<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
    }

    PATTERN {
        UNSAFE  [$1<NAME /\(SHRT\|U?CHAR\|U?INT\|LLONG\)_MAX/>]
          <--rf [($1<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [($<INT OR CHAR, BOUNDED[-10000, 10000]>, +, $<INT OR CHAR, BOUNDED[-10000, 10000]>)]
        EXCLUDE [($1, _<, $$)] //@pragma(allow_vague)
          <--rf [($1<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
    }

    PATTERN {
        UNSAFE  [$1<NAME /\(SHRT\|U?CHAR\|U?INT\|LLONG\)_MAX/>]
          <--rf [($1<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [($<INT OR CHAR, BOUNDED[-100, 100]>, *, $<INT OR CHAR, BOUNDED[-100, 100]>)]
        EXCLUDE [($1, _<, $$)] //@pragma(allow_vague)
          <--if [($1<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
    }

//  CHAR : 127
// SHORT : 32767
//   INT : 2147483647
// LLONG : 9223372036854775807
// UCHAR : 0xff
//  UINT : 0xffffffff
    PATTERN {
        UNSAFE  [ASSIGN($1 := $<INT OR CHAR, LIT
           /\(127\|32767\|2147483647\|9223372036854775807\|0xff\|0xffffffff\)/>)]
          <--rf [($1<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [($<INT OR CHAR, BOUNDED[-10000, 10000]>, +, $<INT OR CHAR, BOUNDED[-10000, 10000]>)]
        EXCLUDE [($1, _<, $$)] //@pragma(allow_vague)
          <--rf [($1<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
    }

    PATTERN {
        UNSAFE  [ASSIGN($1 := $<INT OR CHAR, LIT
           /\(127\|32767\|2147483647\|9223372036854775807\|0xff\|0xffffffff\)/>)]
          <--rf [($1<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [($1, _<, $$)] //@pragma(allow_vague)
          <--if [($1<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
    }

    PATTERN {
        UNSAFE  [[rand,RAND32,RAND64]()]
          <--if [($0<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [($<INT OR CHAR, BOUNDED[-10000, 10000]>, +, $<INT OR CHAR, BOUNDED[-10000, 10000]>)]
        EXCLUDE [($1, _<, $$)] //@pragma(allow_vague)
          <--rf [($1<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [[rand,RAND32,RAND64]()]
          <--if [#_.sanitizer($0)]
          <--if [($0<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
    }

    PATTERN {
        UNSAFE  [[rand,RAND32,RAND64]()]
          <--if [($0<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [($1, _<, $$)] //@pragma(allow_vague)
          <--if [($1<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [[rand,RAND32,RAND64]()]
          <--if [#_.sanitizer($0)]
          <--if [($0<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
    }
}
ENDIF // !(product == "beSOURCE")

//////////////////////////////////////////////////////////////////////////////
// CWE-194 Unexpected Sign Extension

RULE "51000194" {
    UNSAFE VSP[SASP, C,194]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-195 Signed to Unsigned Conversion Error

RULE "51000195" {
    UNSAFE VSP[SASP, C,195]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-196 Unsigned to Signed Conversion Error

RULE "51000196" {
    UNSAFE [ASSIGN ($<SIGNED> := $<UNSIGNED>)]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-209 Information Exposure Through an Error Message

GROUP #GetInfo() {
    TEMPLATE #placeholder(...),

    getenv(...)
}

GROUP #PrintError($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /fw?printf/($<NAME /_?stderr/>, $$, ..., $1, ...)
}

GROUP #"51000209".source = #GetInfo
GROUP #"51000209".sink = #PrintError

RULE "51000209" {
    UNSAFE [#_.source()] <--rf [#_.sink($0)]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-242 Use of Inherently Dangerous Function

GROUP #Danger() {
    TEMPLATE #placeholder(...),

    {{\(gets
\|sprintf
\|strcat
\|strcpy
\|vsprintf
\)}}(...)
}

GROUP #"51000242".blacklist = #Danger

RULE "51000242" {
    UNSAFE [#_.blacklist()]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-243 Creation of chroot Jail Without Changing Working Directory

GROUP #Chroot() {
    TEMPLATE #placeholder(...),

    chroot(...)
}

GROUP #Chdir($1) {
    TEMPLATE #placeholder(..., $1, ...),

    chdir($1)
}

GROUP #"51000243".chroot = #Chroot
GROUP #"51000243".chdir = #Chdir

RULE "51000243" {
    UNSAFE  [#_.chroot()]
    EXCLUDE [#_.chroot()] ==>cf [#_.chdir("/"<STRING>)]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-244 Improper Clearing of Heap Memory Before Release ('Heap Inspection')

GROUP #ReleaseWithoutClear() {
    TEMPLATE #placeholder(...),

    realloc(...)
}

GROUP #ClearMemory($1) {
    TEMPLATE #placeholder(..., $1, ...),

    SecureZeroMemory($1, ...)
}

GROUP #C_LOGON($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /LogonUser[AW]/($$, $$, $1, ...),
    /\(OCILogon2?\|SQLConnect\)/($$, $$, $$, $$, $$, $1, ...),
    mysql_real_connect($$, $$, $$, $1, ...)
}

GROUP #"51000244".blacklist = #ReleaseWithoutClear
GROUP #"51000244".alloc = #Alloc
GROUP #"51000244".external = #External
GROUP #"51000244".clear = #ClearMemory
GROUP #"51000244".sensitive = #C_LOGON

RULE "51000244" {
    PATTERN {
        UNSAFE  [#_.blacklist()]
    }

    PATTERN {
        UNSAFE  [#_.alloc()] <--if [#_.sensitive($0)]
        EXCLUDE [#_.sensitive($1)] -->if [#_.clear($1)]
    }

    PATTERN {
        UNSAFE  [#_.external($1)] <--if [#_.sensitive($1)]
        EXCLUDE [#_.sensitive($1)] -->if [#_.clear($1)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-247 Reliance on DNS Lookups in a Security Decision

GROUP #DNSFunc() {
    TEMPLATE #placeholder(...),

    [gethostbyaddr,gethostbyname,gethostbyname2](...)
}

GROUP #"51000247".dns = #DNSFunc
IF !(product == "beSOURCE") THEN
GROUP #"51000247".check = #StrCmpFunc
ENDIF

RULE "51000247" {
    PATTERN {
        UNSAFE [#_.dns()]
         <--if [ASSIGN($1 := inet_addr($0))]
         <--if [connect($$, $1, $$)]
    }

    // PATTERN {
    //     UNSAFE [#CGI_Input($1)] <--if [#_.check($1)] <--if [$0] in IFCOND
    // }
}

// beSOURCE: Too slow
IF !(product == "beSOURCE") THEN
ADD-PATTERN "51000247" {
    UNSAFE [#_.dns()] <--if [#_.check($0)] <--if [$0@checked]
}

ADD-PATTERN "51000247" {
    UNSAFE [#_.dns()] <--if [#_.check($0)@checked]
}
ENDIF

//////////////////////////////////////////////////////////////////////////////
// CWE-251 Often Misused: String Management

GROUP #MBSFunc() {
    TEMPLATE #placeholder(...),

    {{_mbs\(
cpy
\|dec
\|inc
\|len
\|ncat
\|ncpy
\|nextc
\|nset
\|rev
\|set
\|str
\|tok
\)}}(...)
}

GROUP #"51000251".blacklist = #MBSFunc

RULE "51000251" {
    UNSAFE [#_.blacklist()]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-252 Unchecked Return Value

GROUP #"51000252".lock = #PthreadMutexLock
GROUP #"51000252".alloc = #UnsignedAllocFunc
GROUP #"51000252".read = #StrDangerousReadFunc

RULE "51000252" {
    PATTERN {
        UNSAFE  [#_.lock($$)]
        EXCLUDE [#_.lock($$)] ==>rf [$0] in IFCOND
        EXCLUDE [#_.lock($$)] ==>rf [$0] in LOOPCOND
    }

    PATTERN {
        UNSAFE  [#_.alloc($$)]
        EXCLUDE [#_.alloc($$)] ==>rf [$0] in IFCOND
        EXCLUDE [#_.alloc($$)] ==>rf [$0] in LOOPCOND
        EXCLUDE [#_.alloc($$)] ==>rf [realloc($0, ...)]
    }

    PATTERN {
        UNSAFE  [fgets($1,...)] <--rf [#_.read($1)]
        EXCLUDE [fgets($1,...)] <--df [$0] in IFCOND
          <--rf [#_.read($1)]
        EXCLUDE [fgets($1,...)] <--df [$0] in LOOPCOND
          <--rf [#_.read($1)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-256 Plaintext Storage of a Password

GROUP #Decrypt($1) {
    TEMPLATE #placeholder(..., $1, ...),

    CryptDecrypt($$, $$, $$, $$, $1, $$)
}

GROUP #"51000256".source = #External
GROUP #"51000256".sink = #C_LOGON
GROUP #"51000256".decrypt = #Decrypt

GROUP #"51000256".sanitizer($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51000256" {
    UNSAFE  [#_.source($1)] <--if [#_.sink($1)]
    EXCLUDE [#_.decrypt($1)] <--if [#_.sink($1)]
    EXCLUDE [#_.decrypt($1)] <--if [memcpy($2, $1, $$)] <--if [#_.sink($2)]
    EXCLUDE [#_.source($1)] <--if [#_.sanitizer($1)] <--if [#_.sink($0)]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-258 Empty Password in Configuration File

GROUP #"51000258".source = #FileRead
GROUP #"51000258".sink = #DBCon

GROUP #"51000258".sanitizer($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51000258" {
    UNSAFE  [#_.source($1)] -->if [#_.sink($1)]
    EXCLUDE [#_.source($1)] -->if [#_.sanitizer($1)] -->if [#_.sink($1)]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-259 Use of Hard-coded Password

GROUP #"51000259".password = #C_LOGON
GROUP #"51000259".external = #External

RULE "51000259" {
    PATTERN {
        UNSAFE  [$1<CONSTANT>] //@pragma(allow_vague)
          <--rf [#_.password($1)]
        EXCLUDE [$1<LIT "\0">] <--rf [#_.password($1)]
        EXCLUDE [#_.external($1)] <--rf [#_.password($1)]
    }

    PATTERN {
        UNSAFE  [#StrMoveFunc($1, $<CONSTANT>)] <--if [#_.password($1)]
        EXCLUDE [#_.external($1)] <--rf [#_.password($1)]
    }

    PATTERN {
        UNSAFE  [$1<CONSTANT>] //@pragma(allow_vague)
          <--rf [#StrMoveFunc($2, $1)] <--rf [#_.password($2)]
        EXCLUDE [#_.external($1)] <--rf [#_.password($1)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-260 Password in Configuration File

GROUP #"51000260".source = #FileRead
GROUP #"51000260".sink = #DBCon

GROUP #"51000260".sanitizer($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51000260" {
    UNSAFE  [#_.source($1)] -->if [#_.sink($1)]
    EXCLUDE [#_.source($1)] -->if [#_.sanitizer($1)] -->if [#_.sink($1)]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-261 Weak Cryptography for Passwords

GROUP #CBase64() {
    TEMPLATE #placeholder(...),

    /\([bB]ase64\(_?Decode\)?\|unbase64\)/(...)
}

GROUP #"51000261".blacklist = #CBase64
GROUP #"51000261".password = #DBCon

RULE "51000261" {
    UNSAFE [#_.blacklist()] -->cf [#_.password($$)]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-266 Incorrect Privilege Assignment

RULE "51000266" {
    UNSAFE [#SetID()]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-272 Least Privilege Violation

GROUP #PrvlgFn() {
    TEMPLATE #placeholder(...),

    chroot(...)
}

GROUP #CreateProcess($1) {
    TEMPLATE #placeholder(..., $1, ...),

    [CreateProcessA,CreateProcessW]($$, $1, ...),
    [CreateProcessAsUserA,CreateProcessAsUserW]($$, $$, $1, ...)
}

GROUP #RegKey($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /Reg\(Create\|Open\)Key\(Ex\)?[AW]/($1, ...)
}

RULE "51000272" {
    PATTERN {
        UNSAFE  [#PrvlgFn()]
        EXCLUDE [#PrvlgFn()] ==>cf [#SetID()]
    }

    PATTERN {
        UNSAFE  [#CreateProcess($<STRING>)]
        EXCLUDE [#CreateProcess($<LIT {{".*".*}}>)]
    }

    PATTERN {
        UNSAFE [#RegKey($<NAME HKEY_LOCAL_MACHINE>)]
    }

    PATTERN {
        UNSAFE [/SHRegCreateUSKey[AW]/($$, $$, $$, $$, $<NAME SHREGSET_HKLM>)]
    }

    PATTERN {
        UNSAFE [/SHRegOpenUSKey[AW]/($$, $$, $$, $$, "1"<INT>)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-285 Improper Authorization

GROUP #CLDAPAuth($1, $2, $3) {
    TEMPLATE #placeholder($1, ..., $2, ..., $3, ...),

    /ldap_simple_bind\(_s\)?/($1, $2, $3)
}

GROUP #LDAPSearch($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /ldap_search\(_s\)?/($1, ...)
}

GROUP #"51000285".auth = #CLDAPAuth
GROUP #"51000285".search = #LDAPSearch

RULE "51000285" {
    PATTERN {
        UNSAFE  [#_.search($$)]
        EXCLUDE [#_.auth($1, $<NOT NULLABLE>, $<NOT NULLABLE>)]
          <--if [#_.search($1)]
    }

    PATTERN {
        UNSAFE  [CreateDesktopA($$, $$, $$, $$, $<NAME GENERIC_ALL>, $$)]
        EXCLUDE [CreateDesktopA($$, $$, $$, $$, $<NAME GENERIC_ALL>, $$)] in IFBODY
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-307 Improper Restriction of Excessive Authentication Attempts

GROUP #Auth() {
    TEMPLATE #placeholder(...),

    AuthenticateUser(...)
}

GROUP #"51000307".auth = #Auth

RULE "51000307" {
    PATTERN {
        UNSAFE  [#_.auth()] in LOOPBODY
        EXCLUDE [[$$, <, $<INT>, >]] in LOOPCOND
          <--cf [#_.auth()] in LOOPBODY
        EXCLUDE [#_.auth()] in LOOPBODY
          -->cf [[$$, <, $<INT>, >]] in LOOPCOND
    }

    // FIXME: What's the point?
    // UNSAFE  [#ExtFunc()] <--if [#StrCmpFunc($0)] in IFCOND
    // EXCLUDE [#StrCmpFunc($$)] in IFCOND -->cf [[$$, >_< ,$<INT>, >_<]] in IFCOND
    // UNSAFE  [#ExtFunc2($1)] <--if [#StrCmpFunc($1)] in IFCOND
    // EXCLUDE [#StrCmpFunc($$)] in IFCOND -->cf [[$$, >_< ,$<INT>, >_<]] in IFCOND
}

//////////////////////////////////////////////////////////////////////////////
// CWE-312 Cleartext Storage of Sensitive Information

GROUP #Output($1) {
    TEMPLATE #placeholder(..., $1, ...),

    [printf,wprintf]($$, ..., $1, ...),
    /fw?printf/($$, $$, ..., $1, ...),
    /\(f?puts\|fwrite\)/($1, ...),
    write($$, $1, $$)
}

GROUP #"51000312".source = #External
GROUP #"51000312".decrypt = #Decrypt
GROUP #"51000312".sensitive = #C_LOGON
GROUP #"51000312".stdin = #ReadFromStdin

RULE "51000312" {
    // PATTERN {
    //     UNSAFE [#_.source1()] <--if [#_.output($0)]
    // }

    // PATTERN {
    //     UNSAFE [#_.source2($1)] <--if [#_.output($1)]
    // }

    // PATTERN {
    //     UNSAFE [$1<EXTERN>] <--if [#_.output($1)]
    // }

    // PATTERN {
    //     UNSAFE  [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
    //       <--if [#RECV($1, $2)] <--if [#_.output($2)]
    //     EXCLUDE [memcpy($1, ...)] <--if [#_.output($1)]
    // }

    PATTERN {
        UNSAFE  [recv($$, $1, $$, $$)] <--if [#_.sensitive($1)]
        EXCLUDE [#_.decrypt($1)] <--if [memcpy($2, $1, $$)] <--if [#_.sensitive($2)]
    }

    PATTERN {
        UNSAFE  [#_.source($1)] \ [#_.stdin()]
          <--if [#_.sensitive($1)]
        EXCLUDE [#_.decrypt($2)] <--if [memcpy($3, $2, $$)] <--if [#_.sensitive($3)]
    }
}

// UNSAFE  [#ExtFunc()] <--if [#Output($0)]
// UNSAFE  [#ExtFunc2($1)] <--if [#Output($1)]
// UNSAFE  [$1<EXTERN>] <--if [#Output($1)]
// UNSAFE  [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)] <--if [#RECV($1, $2)] <--if [#Output($2)]
// EXCLUDE [memcpy($1, ...)] <--if [#Output($1)]

//////////////////////////////////////////////////////////////////////////////
// CWE-319 Cleartext Transmission of Sensitive Information

GROUP #"51000319".source = #External
GROUP #"51000319".decrypt = #Decrypt
GROUP #"51000319".sensitive = #C_LOGON

RULE "51000319" {
    PATTERN {
        UNSAFE  [#_.source($1)] <--if [#_.sensitive($1)]
        EXCLUDE [#_.decrypt($2)] <--if [memcpy($3, $2, $$)] <--if [#_.sensitive($3)]
    }

    PATTERN {
        UNSAFE  [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
          <--if [#RECV($1, $2)] <--if [#_.sensitive($2)]
        EXCLUDE [memcpy($1, ...)] <--if [#_.sensitive($1)]
        EXCLUDE [#_.decrypt($2)] <--if [memcpy($3, $2, $$)] <--if [#_.sensitive($3)]
    }

    PATTERN {
        UNSAFE  [recv($$, $1, $$, $$)] <--if [#_.sensitive($1)]
        EXCLUDE [#_.decrypt($2)] <--if [memcpy($3, $2, $$)] <--if [#_.sensitive($3)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-321 Use of Hard-coded Cryptographic Key

GROUP #STRcomp($1, $2) {
    TEMPLATE #placeholder($1, ..., $2, ...),

    /strn?cmp/($1, $2, ...)
}

GROUP #EncryptKey($1) {
    TEMPLATE #placeholder(..., $1, ...),

    CryptEncrypt($1, ...)
}

GROUP #"51000321".key = #EncryptKey

RULE "51000321" {
    PATTERN {
        UNSAFE [ASSIGN($1 := crypt(...))] -->rf [#STRcomp($1, $<CONSTANT>)]
         -->if [#DBCon($1)]
    }

    PATTERN {
        UNSAFE [ASSIGN($1 := crypt(...))] -->rf [#STRcomp($<CONSTANT>, $1)]
         -->if [#DBCon($1)]
    }

    PATTERN {
        UNSAFE [$1<CONSTANT>] //@pragma(allow_vague)
         <--if [#_.key($1)]
    }

    PATTERN {
        UNSAFE [#StrMoveFunc($1, $<CONSTANT>)] <--if [#_.key($1)]
    }

    PATTERN {
        UNSAFE [#StrMoveFunc($1, $<CONSTANT>)] <--if [CryptHashData($2, $1, ...)]
         <--if [CryptDeriveKey($$, $$, $2, $$, $3)] <--if [CryptEncrypt($3, ...)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-323 Reusing a Nonce, Key Pair in Encryption

GROUP #HashEnc($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(MD5\|SHA1\)/($1, ...)
}

GROUP #"51000323".nonce = #HashEnc

RULE "51000323" {
    PATTERN {
        UNSAFE [$1<CONSTANT>] //@pragma(allow_vague)
         <--if [#_.nonce($1)]
    }

    PATTERN {
        UNSAFE [#StrMoveFunc($1, $<CONSTANT>)] <--if [#_.nonce($1)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-326 Inadequate Encryption Strength

GROUP #InadequateEncrypt() {
    TEMPLATE #placeholder(...),

    RSA_generate_key($<INT, LIT /\(1\|128\|16\|2\|256\|32\|4\|512\|64\|8\)/>, $$, $$, $$),
    opensslcrypt($$, $<BOUNDED[*,127]>, ...)
}

GROUP #"51000326".blacklist = #InadequateEncrypt

RULE "51000326" {
    UNSAFE [#_.blacklist()]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-327 Use of a Broken or Risky Cryptographic Algorithm

GROUP #BadEnc() {
    TEMPLATE #placeholder(),

    /EVP_des_\(cbc\|cfb\|ecb\|ofb\)/(...)
}

GROUP #"51000327".blacklist = #BadEnc

RULE "51000327" {
    PATTERN {
        UNSAFE [#_.blacklist()]
    }

    PATTERN {
        UNSAFE [CryptDeriveKey($$, $<NAME /CALG_\(DES\|3DES\|RC5\)/>, $$, $$, $1)]
         <--if [CryptDecrypt($1, ...)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-328 Reversible One-Way Hash

GROUP #C_WeakHashFn() {
    TEMPLATE #placeholder(...),

    /MD[245]_\(Final\|Init\|Update\)/(...)
}

GROUP #"51000328".blacklist = #C_WeakHashFn

RULE "51000328" {
    UNSAFE [#_.blacklist()]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-329: Not Using a Random IV with CBC Mode

GROUP #CEncInit($1) {
    TEMPLATE #placeholder(..., $1, ...),

    EVP_EncryptInit($$, $$, $$, $1)
}

GROUP #"51000329".iv = #CEncInit

RULE "51000329" {
    PATTERN {
        UNSAFE [#_.iv($<CONSTANT>)]
    }

    PATTERN {
        UNSAFE [$1<CONSTANT>] //@pragma(allow_vague)
         -->rf [#_.iv($1)]
    }

    PATTERN {
        UNSAFE [memset($1, $<CONSTANT>, ...)] <--rf [#_.iv($1)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-330 Use of Insufficiently Random Values

GROUP #CSetSeed($1) {
    TEMPLATE #placeholder(..., $1, ...),

    [srand,srandom]($1)
}

GROUP #RNG() {
    TEMPLATE #placeholder(...),

    [rand,random](...)
}

GROUP #PredictableSrc() {
    TEMPLATE #placeholder(...),

    /\(getp?pid\|gettimeofday\|time\)/(...)
}

GROUP #"51000330".predictable = #PredictableSrc
GROUP #"51000330".seed = #CSetSeed
GROUP #"51000330".random = #RNG

RULE "51000330" {
    PATTERN {
        UNSAFE [#_.seed($<CONSTANT>)] <--cf [#_.random()]
    }

    PATTERN {
        UNSAFE [#_.predictable()] <--cf [#_.seed($$)]
    }

    PATTERN {
        UNSAFE  [#_.random()]
        EXCLUDE [#_.seed($$)] <--cf [#_.random()]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-359 Privacy Violation

GROUP #CPrivacyFn() {
    TEMPLATE #placeholder(...),

    /[Gg]etPassword/(...)
}

GROUP #"51000359".privacy = #CPrivacyFn
GROUP #"51000359".output = #Output

GROUP #"51000359".sanitizer($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51000359" {
    UNSAFE  [#_.privacy()] -->rf [#_.output($0)]
    EXCLUDE [#_.privacy()] -->rf [#_.sanitizer($0)] -->rf [#_.output($0)]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-364 Signal Handler Race Condition

RULE "51000364" {
    PATTERN {
        UNSAFE VSP[SASP, C,364]
    }

    PATTERN {
        UNSAFE VSP[SASP, C,3641]
    }

    PATTERN {
        UNSAFE [signal($$,$1)] -->rf [signal($$,$1)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-367 Time-of-check Time-of-use (TOCTOU) Race Condition

GROUP #C_CHECK($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(access\|f?stat\)/($1, ...)
}

GROUP #C_CHECK_WIN($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /_\(access\|f?stat\)/($1, ...)
}

GROUP #UseFileWin($1) {
    TEMPLATE #placeholder(..., $1, ...),

    _open($1, ...)
}

GROUP #"51000367".check($1) {
    TEMPLATE #placeholder(..., $1, ...),

    #C_CHECK, #C_CHECK_WIN
}

GROUP #"51000367".use($1) {
    TEMPLATE #placeholder(..., $1, ...),

    #UseFile, #UseFileWin
}

RULE "51000367" {
    UNSAFE [#_.check($1)] <--if [#_.use($1)]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-369 Divide By Zero
// DEPRECATED: Use 51008369 instead.

RULE "51000369" {
    PATTERN {
        UNSAFE  [($$, /, $$)] //@pragma(allow_vague)
        EXCLUDE [$1] in IFCOND  //@pragma(allow_vague)
          <==rf [($$, /, $1)]  //@pragma(allow_vague)
    }

    PATTERN {
        UNSAFE [($$, /, $<ZERO>)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-377 Insecure Temporary File

GROUP #"51000377".blacklist = #WeakTempFunc

RULE "51000377" {
    UNSAFE [#_.blacklist()]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-385 Covert Timing Channel

RULE "51000385" {
    PATTERN {
        UNSAFE [return] in IFBODY
    }

    PATTERN {
        UNSAFE [return] in LOOPBODY
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-386 Symbolic Name not Mapping to Correct Object

// 삭제해야함
RULE "51000386" {
    PATTERN {
        UNSAFE [#WeakTempFunc()]
    }

    PATTERN {
        UNSAFE [access($1,...)] <--rf [fopen($1,...)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-390 Detection of Error Condition Without Action

GROUP #ErroredFunc() {
    TEMPLATE #placeholder(...),

    [calloc,CreateMutex,CreateNamedPipeA,
     fgets,fgetws,fopen,fprintf,fwprintf,fputc,fputs,fputwc,fputws,
     fread,fscanf,fwscanf,fwrite,GetLastError,malloc,
     putc,puts,putwc,putws,putchar,putwchar,_putws,
     realloc,remove,rename,scanf,wscanf,
     _snprintf,_snwprintf,sscanf,swscanf,_wfopen,wremove,_wremove,
     wrename,_wrename
    ](...)
}

GROUP #ErrCode() {
    TEMPLATE #placeholder(...),

    [sqrt,strtol,wcstombs](...)
}

GROUP #ErrCodeDirect() {
    TEMPLATE #placeholder(...),

    sqrt(...)
}

GROUP #CustomErrored() {
    TEMPLATE #placeholder(...),

    [ImpersonateSelf,RpcImpersonateClient](...)
}

GROUP #"51000390".error() {
    TEMPLATE #placeholder(..., $1, ...),

    #ErroredFunc, #CustomErrored
}

GROUP #"51000390".errno = #ErrCodeDirect
GROUP #"51000390".werrno = #ErrCode

RULE "51000390" {
    PATTERN {
        UNSAFE [#_.error()] in IFCOND in IF<EMPTY>
    }

    PATTERN {
        UNSAFE [#_.error()] <--rf [$0] in IFCOND in IF<EMPTY>
    }

    PATTERN {
        UNSAFE [#_.werrno()] <--cf [_get_errno($1)]
         <--rf [$1] in IFCOND in IF<EMPTY>
    }

    PATTERN {
        UNSAFE [#_.errno()] <--cf [$<NAME errno>] in IFCOND in IF<EMPTY>
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-400 Uncontrolled Resource Consumption ('Resource Exhaustion')

GROUP #SLEEP($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(s\|S\|us\)leep/($1)
}

GROUP #RES_EX() {
    TEMPLATE #placeholder(...),

    /\(printLine\|fwrite\)/(...)
}

GROUP #"51000400".source($1) {
    TEMPLATE #placeholder(...),

    #External, RAND32():$1
}

GROUP #"51000400".resource1 = #SLEEP
GROUP #"51000400".resource2 = #RES_EX

RULE "51000400" {
    PATTERN {
        UNSAFE  [#_.source($1)] <--if [#_.resource1($1)]
        EXCLUDE AND[[[$1, _<, $$, >_]] in IFCOND <--rf [#_.resource1($1)];
                   [[$1, >_, $$, _<]] in IFCOND <--rf [#_.resource1($1)]]
    }

    PATTERN {
        UNSAFE  [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
          <--if [#RECV($1, $2)] <--if [atoi($2)] <--rf [#_.resource1($0)]
        EXCLUDE AND[[[$1, _<, $$, >_]] in IFCOND <--rf [#_.resource1($1)];
                   [[$1, >_, $$, _<]] in IFCOND <--rf [#_.resource1($1)]]
    }

    PATTERN {
        UNSAFE  [RAND32()] <--rf [$0<INT>] in LOOPCOND
          <--cf [#_.resource2()] in LOOPBODY
        EXCLUDE AND[[[$1, _<, $$, >_]] in IFCOND <--rf [$1] in LOOPCOND
                    <--cf [#_.resource2()] in LOOPBODY;
                    [[$1, >_, $$, _<]] in IFCOND <--rf [$1] in LOOPCOND
                    <--cf [#_.resource2()] in LOOPBODY]
    }

    PATTERN {
        UNSAFE  [#_.source($1)] <--rf [$1<INT>] in LOOPCOND
          <--cf [#_.resource2()] in LOOPBODY
        EXCLUDE AND[[[$1, _<, $$, >_]] in IFCOND <--rf [$1] in LOOPCOND
                    <--cf [#_.resource2()] in LOOPBODY;
                    [[$1, >_, $$, _<]] in IFCOND <--rf [$1] in LOOPCOND
                    <--cf [#_.resource2()] in LOOPBODY]
    }

    PATTERN {
        UNSAFE  [#_.source($1)] <--rf [atoi($1)] <--rf [$0<INT>] in LOOPCOND
          <--cf [#_.resource2()] in LOOPBODY
        EXCLUDE AND[[[$1, _<, $$, >_]] in IFCOND <--rf [$1] in LOOPCOND
                    <--cf [#_.resource2()] in LOOPBODY;
                    [[$1, >_, $$, _<]] in IFCOND <--rf [$1] in LOOPCOND
                    <--cf [#_.resource2()] in LOOPBODY]
    }

    PATTERN {
        UNSAFE  [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
          <--if [#RECV($1, $2)] <--if [atoi($2)] <--rf [$0<INT>] in LOOPCOND
          <--cf [#_.resource2()]
        EXCLUDE AND[[[$1, _<, $$, >_]] in IFCOND <--rf [$1] in LOOPCOND
                    <--cf [#_.resource2()];
                    [[$1, >_, $$, _<]] in IFCOND <--rf [$1] in LOOPCOND
                    <--cf [#_.resource2()]]
    }
}

// RULE "51000401" {
//     PATTERN {
//         UNSAFE VSP[SASP, C,401]
//     }
// }

//////////////////////////////////////////////////////////////////////////////
// CWE-404: Improper Resource Shutdown or Release

GROUP #AllocDBHandle($1) {
    TEMPLATE #placeholder(..., $1, ...),

    SQLAllocHandle($$,$$,$1)
}

GROUP #FreeSocket($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /close\(socket\)?/($1)
}

GROUP #AllocSocket() {
    TEMPLATE #placeholder(...),

    /\(accept\|socket\)/(...)
}

GROUP #AllocMem() {
    TEMPLATE #placeholder(...),

    /[mc]alloc/(...)
}

GROUP #FreeDBHandle($1) {
    TEMPLATE #placeholder(..., $1, ...),

    SQLFreeHandle($$,$1)
}

GROUP #FOpen() {
    TEMPLATE #placeholder(...),

    /f\(re\)?open/(...)
}

GROUP #FClose($1) {
    TEMPLATE #placeholder(..., $1, ...),

    fclose($1)
}

GROUP #FreeHeap($1) {
    TEMPLATE #placeholder(..., $1, ...),

    free($1)
}

GROUP #"51000404".close($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51000404" {
    PATTERN {
        UNSAFE  [#AllocDBHandle($$)]
        EXCLUDE [#AllocDBHandle($1)] -->if [#FreeDBHandle($1)]
        EXCLUDE [#AllocDBHandle($1)] -->if [#_.close($1)]
    }

    PATTERN {
        UNSAFE  [#AllocSocket()]
        EXCLUDE [#AllocSocket()] -->if [#FreeSocket($0)]
        EXCLUDE [#AllocSocket()] -->if [#_.close($0)]
    }

    PATTERN {
        UNSAFE  [#FOpen()]
        EXCLUDE [#FOpen()] -->if [#FClose($0)]
        EXCLUDE [#FOpen()] -->if [#_.close($0)]
    }

    PATTERN {
        UNSAFE  [open(...)]
        EXCLUDE [open(...)] -->if [close($0)]
        EXCLUDE [open(...)] -->if [#_.close($0)]
    }

    PATTERN {
        UNSAFE  [_open(...)]
        EXCLUDE [_open(...)] -->if [_close($0)]
        EXCLUDE [_open(...)] -->if [#_.close($0)]
    }

    PATTERN {
        UNSAFE  [CreateFile(...)]
        EXCLUDE [CreateFile(...)] -->if [CloseHandle($0)]
        EXCLUDE [CreateFile(...)] -->if [#_.close($0)]
    }

    PATTERN {
        UNSAFE  [#AllocMem()]
        EXCLUDE [#AllocMem()] -->if [#FreeHeap($0)]
        EXCLUDE [#AllocMem()] -->if [#_.close($0)]
    }
}


//////////////////////////////////////////////////////////////////////////////
// CWE-413 Improper Resource Locking

GROUP #"51000413".lock = #MutexLock
GROUP #"51000413".unlock = #MutexUnlock

RULE "51000413" {
    UNSAFE  [#_.lock($1)] <--if [#_.unlock($1)]
    EXCLUDE [#_.lock($1)] <--if [$0] in IFCOND
      <--if [#_.unlock($1)]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-414 Missing Lock Check

GROUP #"51000414".lock = #PthreadMutexLock

GROUP #"51000414".check($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51000414" {
    UNSAFE  [#_.lock($$)]
    EXCLUDE [#_.lock($$)] ==>rf [$0] in IFCOND
    EXCLUDE [#_.lock($$)] ==>rf [#_.check($0)]
}

// RULE "51000415" {
//     PATTERN {
//         UNSAFE VSP[SASP, C,415]
//     }
// }

// RULE "51000416" {
//     PATTERN {
//         UNSAFE VSP[SASP, C,416]
//     }
// }

//////////////////////////////////////////////////////////////////////////////
// CWE-434 Unrestricted Upload of File with Dangerous Type

GROUP #UploadFileName($1) {
    TEMPLATE #placeholder(..., $1, ...),

    cgiFormFileName("file"<STRING>, $1, $$)
}

GROUP #"51000434".upload = #UploadFileName
GROUP #"51000434".check = #StrCmpFunc

RULE "51000434" {
    UNSAFE  [#_.upload($$)]
    EXCLUDE [#_.upload($1)] -->rf [#_.check($1)] in IFCOND
}

// RULE "51000457" {
//     PATTERN {
//         UNSAFE VSP[SASP, C, 457]
//     }
// }

// RULE "51000466" {
//     PATTERN {
//         UNSAFE VSP[SASP, C,466]
//     }
// }

//////////////////////////////////////////////////////////////////////////////
// CWE-470 Use of Externally-Controlled Input to Select Classes or Code

GROUP #"51000470".source = #External
GROUP #"51000470".sink = #LDFunc

RULE "51000470" {
    UNSAFE [#_.source($1)] <--if [#_.sink($1)]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-474 Use of Function with Inconsistent Implementations

GROUP #InconsistFn() {
    TEMPLATE #placeholder(...),

    sysv_signal(...)
}

GROUP #"51000474".blacklist = #InconsistFn

RULE "51000474" {
    UNSAFE [#_.blacklist()]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-475 Undefined Behavior for Input to API

GROUP #UndefBehav() {
    TEMPLATE #placeholder(...),

    {{__\(
fxstat\(64\)?
\|lxstat\(64\)?
\|wcsto\(d\|f\|l\|ld\|ul\)_internal
\|xmknod
\|xstat\(64\)?
\)}}(...)
}

GROUP #"51000475".blacklist = #UndefBehav

RULE "51000475" {
    UNSAFE [#_.blacklist()]
}

// RULEID "51000476"
// UNSAFE VSP[SASP, C,476]

//////////////////////////////////////////////////////////////////////////////
// CWE-477 Use of Obsolete Functions

GROUP #obsoleteFn() {
    TEMPLATE #placeholder(...),

    /SQLAlloc\(Connect\|Env\|Stmt\)\|getpw/(...)
}

GROUP #"51000477".blacklist = #obsoleteFn

RULE "51000477" {
    UNSAFE [#_.blacklist()]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-484 Omitted Break Statement in Switch

RULE "51000484" {
    UNSAFE VSP[SASP, C,484]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-489 Leftover Debug Code

RULE "51000489" {
    PATTERN {
        UNSAFE [$<ARRAY, LIT /\(debug\|DEBUG\)/>] in IFCOND
    }
    PATTERN {
        UNSAFE [$<STRING, LIT /\(debug\|DEBUG\)/>] in IFCOND
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-494 Download of Code Without Integrity Check

GROUP #Download($1) {
    TEMPLATE #placeholder(..., $1, ...),

    curl_easy_setopt($$, $<NAME CURLOPT_WRITEDATA>, $1)
}

GROUP #UseDownloadedFile($1) {
    TEMPLATE #placeholder(..., $1, ...),

    fgets($$, $$, $1)
}

GROUP #ReadForChecksum($1, $2) {
    TEMPLATE #placeholder($2, ..., $1, ...),

    fread($2, $$, $$, $1)
}

GROUP #ComputeChecksum($1, $2) {
    TEMPLATE #placeholder($2, ..., $1, ...),

    MD5_Update($2, $1, $$)
}

GROUP #GetChecksum($1, $2) {
    TEMPLATE #placeholder($2, ..., $1, ...),

    MD5_Final($2, $1)
}

GROUP #"51000494".download = #Download
GROUP #"51000494".use = #UseDownloadedFile
GROUP #"51000494".compare = #StrCmpFunc

RULE "51000494" {
    UNSAFE  [#_.download($1)] <--if [#_.use($1)]
    EXCLUDE [#_.download($1)]
      <--if [#ReadForChecksum($1, $2)]
      <--if [#ComputeChecksum($2, $3)]
      <--if [#GetChecksum($3, $4)]
      <--if [#_.compare($4)]
      <--if [#_.use($1)]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-497 Exposure of System Data to an Unauthorized Control Sphere

GROUP #GetSystemData() {
    TEMPLATE #placeholder(...),

    getenv(...)
}

GROUP #PutSystemData($1) {
    TEMPLATE #placeholder(..., $1, ...),

    getcwd($1, $$)
}

GROUP #"51000497".source1 = #GetSystemData
GROUP #"51000497".source2 = #PutSystemData
GROUP #"51000497".sink = #Output

GROUP #"51000497".sanitizer($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51000497" {
    PATTERN {
        UNSAFE  [#_.source1()] <--if [#_.sink($0)]
        EXCLUDE [#_.source1()] <--if [#_.sanitizer($0)] <--if [#_.sink($0)]
    }

    PATTERN {
        UNSAFE  [#_.source2($1)] <--if [#_.sink($1)]
        EXCLUDE [#_.source2($1)] <--if [#_.sanitizer($1)] <--if [#_.sink($0)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-521 Weak Password Requirements

// FIXME: Rewrite neeeded.
RULE "51000521" {
    // Hack for KISA sample
    PATTERN "KISA" {
        UNSAFE  [#External($1)] <--if [#StrCmp($<NAME "sz_pa">, $1)] in IFCOND
        EXCLUDE [strlen($1)] <--df [[$0, _<, $<INT>, >_]] in IFCOND
          <--if [#StrCmp($<NAME "sz_pa">, $1)] in IFCOND
    }

    PATTERN "KISA" {
        UNSAFE  [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)] <--if [#RECV($1, $2)]
          <--if [#StrCmp($<NAME "sz_pa">, $2)] in IFCOND
        EXCLUDE [strlen($1)] <--df [[$0, _<, $<INT>, >_]] in IFCOND
          <--if [#StrCmp($<NAME "sz_pa">, $1)] in IFCOND
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-558 Use of getlogin() in Multithreaded Application

RULE "51000558" {
    UNSAFE [getlogin()]
}

// RULEID "51000562"
// UNSAFE VSP[SASP, C,562]

// CWE-563 Unused Variable
// [SP] 사용되지 않는 변수
//RULEID "51000563"
//UNSAFE VSP[SASP, C,563]

//////////////////////////////////////////////////////////////////////////////
// CWE-570 Expression is Always False

RULE "51000570" {
    UNSAFE VSP[SASP, C,570]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-571 Expression is Always True

RULE "51000571" {
    UNSAFE VSP[SASP, C,571]
}

//RULEID "51000587"
//UNSAFE VSP[SASP, C,587]

//////////////////////////////////////////////////////////////////////////////
// CWE-590 Free of Memory not on the Heap

GROUP #"51000590".alloc = #Alloc
GROUP #"51000590".free = #FreeHeap

RULE "51000590" {
    UNSAFE  [#_.free($$)]
    EXCLUDE [#_.alloc()] <--if [#_.free($0)]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-601 URL Redirection to Untrusted Site ('Open Redirect')

GROUP #"51000601".source = #CGI_Input
GROUP #"51000601".sink = #CGI_HeaderLocation

GROUP #"51000601".sanitizer($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51000601" {
    UNSAFE  [#_.source($1)] <--if [#_.sink($1)]
    EXCLUDE [#_.source($1)] <--if [#_.sanitizer($1)] <--if [#_.sink($1)]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-605 Multiple Binds to the Same Port

RULE "51000605" {
    PATTERN {
        UNSAFE AND[[setsockopt($1, $<NAME SOL_SOCKET>, $<NAME SO_REUSEADDR>, $$, $$)]
                   <--if [bind($1, $$, $$)];
                   [ASSIGN($2<NAME sin_addr.s_addr> := htonl($<NAME INADDR_ANY>))]
                   <--if [bind($$, $2, $$)]]
    }

    PATTERN {
        UNSAFE AND[[setsockopt($1, "0xffff"<INT>, "0x0004"<INT>, $$, $$)]
                   <--if [bind($1, $$, $$)];
                   [ASSIGN($2<NAME sin_addr.s_addr> := htonl("0x00000000"<CLASS in_addr_t>))]
                   <--if [bind($$, $2, $$)]]
    }

    PATTERN {
        UNSAFE [setsockopt($1, $$, $<NAME SO_REUSEADDR>, $$, $$)]
          -->cf [ASSIGN($2<NAME sin_port> := htons($<CONSTANT>))]
          -->if [bind($1, $2, $$)] in LOOPBODY
          -->if [accept($1, $$, $$)] in LOOPBODY
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-606 Unchecked Input for Loop Condition

GROUP #"51000606".input = #External

RULE "51000606" {
    UNSAFE [#_.input($1)] <--if [[$$, _<, $1, >_]] in LOOPCOND
}

//////////////////////////////////////////////////////////////////////////////
// CWE-615 Information Exposure Through Comments

RULE "51000615" {
    PATTERN {
        UNSAFE CMT[
          "\(password\|passwd\|pwd\|pass\) *[=:-] *[a-zA-Z0-9][a-zA-Z0-9]*[ \\n]";
          "\(비밀번호\|비번\|패스워드\|암호\) *[=:-] *[a-zA-Z0-9][a-zA-Z0-9]*[ \\n]";
          "\(비밀번호는\|비번은\|패스워드는\|암호는\) *[a-zA-Z0-9][a-zA-Z0-9]*[ \\n]";
          "using password [a-zA-Z0-9][a-zA-Z0-9]*"
        ]
        EXCLUDE CMT["should pass "]
        EXCLUDE CMT["\(password\|passwd\|pwd\|pass\) *= *[a-zA-Z][a-zA-Z0-9.]*();"]
    }

    PATTERN {
        UNSAFE  CMT["\(password\|passwd\|pwd\|pass\)\( \|[a-zA-Z ]* \)is "]
        EXCLUDE CMT["\(password\|passwd\|pwd\|pass\)\( \|[a-zA-Z ]* \)is [a-z][a-z]*ed "]
        EXCLUDE CMT["\(password\|passwd\|pwd\|pass\)\( \|[a-zA-Z ]* \)is read from"]
        EXCLUDE CMT["passed [a-zA-Z ]* is"]
        EXCLUDE CMT["should pass "]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-643 Improper Neutralization of Data within XPath Expressions

GROUP #XPathExecute($1) {
    TEMPLATE #placeholder(..., $1, ...),

    xmlXPathEvalExpression($1, ...)
}

GROUP #"51000643".source = #External
GROUP #"51000643".sink = #XPathExecute

RULE "51000643" {
    UNSAFE [#_.source($1)] <--if [#_.sink($1)]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-652 Improper Neutralization of Data within XQuery Expressions

GROUP #XQueryExecute($1) {
    TEMPLATE #placeholder(..., $1, ...),

    XQC_Implementation.prepare($$, $1, ...),
    XQC_Expression.execute($1, ...)
}

GROUP #"51000652".source = #External
GROUP #"51000652".sink = #XQueryExecute

RULE "51000652" {
    UNSAFE [#_.source($1)] <--if [#_.sink($1)]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-674 Uncontrolled Recursion

RULE "51000674" {
    UNSAFE VSP[SASP, Common, 674]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-676 Use of Potentially Dangerous Function

GROUP #Banned_string_copy() {
    TEMPLATE #placeholder(...),

    {{\(
l?[sS]tr[cC]py[AW]?
\|wcsn?cpy
\|_\(tcsn?\|mbsn?\|mbsnb\|tc\|mbc\|ftcs\)cpy
\|strncpy
\|StrCpyN[AW]?
\|StrNCpy[AW]?
\|strcpynA
\|lstrcpyn[AW]?
\)}}(...)
}

GROUP #Banned_string_concat() {
    TEMPLATE #placeholder(...),

    {{\(
l?[sS]tr[cC]at[AW]?
\|wcsn?cat
\|_\(tcs\|mbs\)cat
\|StrCatBuff[AW]?
\|StrCatChainW
\|_\(tc\|mbc\|ftcs\|tcsn\|mbsn\|mbsnb\)cat
\|l?strncat
\|StrCatN[AW]?
\|StrNCat[AW]?
\|lstrcatn[AW]?
\)}}(...)
}

GROUP #Banned_sprintf() {
    TEMPLATE #placeholder(...),

    {{\(
w?sprintf[AW]?
\|swprintf
\|_v?stprintf
\|wvsprintf[AW]?
\|vsw?printf
\)}}(...)
}

GROUP #Banned_sprintf_recommended() {
    TEMPLATE #placeholder(...),

    {{\(
wnsprintf[AW]?
\|_snwprintf
\|snt?printf
\|_?vsnprintf
\|_vsn[wt]printf
\|wvnsprintf[AW]?
\)}}(...)
}

GROUP #Banned_n_sprintf_recommmeded() {
    TEMPLATE #placeholder(...),

    {{\(
_sn[wt]?printf
\|nsprintf
\)}}(...)
}

GROUP #Banned_va_sprintf() {
    TEMPLATE #placeholder(...),

    {{\(
wvsprintf[AW]?
\|vsw?printf
\|_vstprintf
\)}}(...)
}

GROUP #Banned_va_n_sprintf_recommended() {
    TEMPLATE #placeholder(...),

    {{\(
_vsn[wt]?printf
\|wvnsprintf[AW]?
\)}}(...)
}

GROUP #Banned_n_string_copy() {
    TEMPLATE #placeholder(...),

    {{\(
\(str\|wcs\)ncpy
\|_\(tcsn\|mbsn\|mbsnb\|fstrn\)cpy
\|StrCpyN[AW]?
\|strcpynA
\|StrNCpy[AW]?
\|lstrcpyn[AW]?
\)}}(...)
}

GROUP #Banned_n_string_concat() {
    TEMPLATE #placeholder(...),

    {{\(
\(str\|wcs\)ncat
\|_\(tcsn\|mbsn\|mbsnb\|fstrn\)cat
\|StrCatN[AW]?
\|StrNCat[AW]?
\|lstrncat
\|lstrcatn[AW]?
\)}}(...)
}

GROUP #Banned_string_tokenizing_recommended() {
    TEMPLATE #placeholder(...),

    {{\(
\(str\|_tcs\|wcs\)tok
\|_mbsto
\)}}(...)
}

GROUP #Banned_makepath_recommended() {
    TEMPLATE #placeholder(...),

    /\(_t\|_\|_w\)?makepath/(...)
}

GROUP #Banned_splitpath_recommended() {
    TEMPLATE #placeholder(...),

    /_[tw]?splitpath/(...)
}

GROUP #Banned_scanf_recommended() {
    TEMPLATE #placeholder(...),

    /\(w\|_t\|s\|sw\|_st\)?scanf/(...)
}

GROUP #Banned_n_scanf_recommended() {
    TEMPLATE #placeholder(...),

    /\(sn\|snw\|_snt\)scanf/(...)
}

GROUP #Banned_numeric_conversion_recommended() {
    TEMPLATE #placeholder(...),

    /_i\(64\)?to[aw]/(...),
    /_u\(i64\|l\)to[atw]/(...)
}

GROUP #Banned_gets() {
    TEMPLATE #placeholder(...),

    /\(gets\|_getts\|_gettws\)/(...)
}

GROUP #Banned_IsBad() {
    TEMPLATE #placeholder(...),

    /IsBad\(Write\|HugeWrite\|Read\|HugeRead\|Code\|String\)Ptr/(...)
}

GROUP #Banned_OEM_conversion_recommended() {
    TEMPLATE #placeholder(...),

    /\(CharToOem\|OemToChar\|CharToOemBuff\)[AW]?/(...)
}

GROUP #Banned_stack_dynamic_malloc_recommended() {
    TEMPLATE #placeholder(...),

    /_?alloca/(...)
}

GROUP #Banned_string_length_recommended() {
    TEMPLATE #placeholder(...),

    /\(\(str\|wcs\|_mbs\|_mbstr\|lstr\)len\|StrLen\)/(...)
}

GROUP #Banned_memory_copy() {
    TEMPLATE #placeholder(...),

    /\(w?memcpy\|RtlCopyMemory\|CopyMemory\)/(...)
}

GROUP #Banned_window_messaging_recommended() {
    TEMPLATE #placeholder(...),

    ChangeWindowMessageFilter(...)
}

GROUP #"51000676".blacklist() {
    TEMPLATE #placeholder(...),

    #Banned_string_copy,
    #Banned_string_concat,
    #Banned_sprintf,
    #Banned_sprintf_recommended,
    #Banned_n_sprintf_recommmeded,
    #Banned_va_sprintf,
    #Banned_va_n_sprintf_recommended,
    #Banned_n_string_copy,
    #Banned_n_string_concat,
    #Banned_string_tokenizing_recommended,
    #Banned_makepath_recommended,
    #Banned_splitpath_recommended,
    #Banned_scanf_recommended,
    #Banned_n_scanf_recommended,
    #Banned_numeric_conversion_recommended,
    #Banned_gets,
    #Banned_IsBad,
    #Banned_OEM_conversion_recommended,
    #Banned_stack_dynamic_malloc_recommended,
    #Banned_string_length_recommended,
    #Banned_memory_copy,
    #Banned_window_messaging_recommended,
}

RULE "51000676" {
    UNSAFE [#_.blacklist()]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-685 Function Call With Incorrect Number of Arguments

RULE "51000685" {
    UNSAFE VSP[SASP, C,685]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-686 Function Call With Incorrect Argument Type

RULE "51000686" {
    UNSAFE VSP[SASP, C,686]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-732 Incorrect Permission Assignment for Critical Resource

RULE "51000732" {
    UNSAFE [umask("0"<INT>)] -->rf [fopen($$, "w"<STRING>)]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-754 Improper Check for Unsual Conditions

// beSOURCE: Too slow. Must be reimplemented.
IF !(product == "beSOURCE") THEN
GROUP #CheckableFunc() {
    TEMPLATE #placeholder(...),

   {{\(
[fs]?w?scanf
\|fwrite
\|f?putw?c
\|putchar
\|f?putw?s
\|\(w\|_w\)?remove
\|\(w\|_w\)?rename
\|_snw?printf
\|Create\(Mutex\|NamedPipe\)[AW]
\|Impersonate\(NamedPipeClient\|Self\)
\|fgetw?s
\|fw?printf
\|fread
\|RpcImpersonateClient
\|putwchar
\|_putws
\)}}(...)
}

GROUP #"51000754".checkable = #CheckableFunc

GROUP #"51000754".check($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51000754" {
    UNSAFE  [#_.checkable()]
    EXCLUDE [#_.checkable()@checked] in IF<NOT EMPTY>
    EXCLUDE [#_.checkable()] -->df [$0@checked] in IF<NOT EMPTY>
    EXCLUDE [#_.checkable()] -->df [#_.check($0)]
}
ENDIF // !(product == "beSOURCE")

//////////////////////////////////////////////////////////////////////////////
// CWE-759 Use of a One-Way Hash without a Salt

GROUP #HashWithoutSalt() {
    TEMPLATE #placeholder(...),

    crypt($$),
    KrdMD5Encrypt($$, "0"<INT>)
}

GROUP #"51000759".blacklist = #HashWithoutSalt

RULE "51000759" {
    PATTERN {
        UNSAFE [simple_digestj(...)] -->if [$0] in IFCOND
    }

    PATTERN {
        UNSAFE [#_.blacklist()]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CWE-775 Missing Release of File Descriptor or Handle after Effective Lifetime

GROUP #"51000775".open = #FOpen
GROUP #"51000775".close = #FClose

RULE "51000775" {
    UNSAFE  [#_.open()]
    EXCLUDE [#_.open()] -->if  [#_.close($0)]
}

//////////////////////////////////////////////////////////////////////////////
// CWE-789 Uncontrolled Memory Allocation

GROUP #"51000789".source = #External
GROUP #"51000789".sink = #UnsignedAllocFunc

GROUP #"51000789".sanitizer($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51000789" {
    UNSAFE  [#_.source($1)] <--if [#_.sink($1)]
    EXCLUDE [#_.source($1)] <--if [#_.sanitizer($1)]
      <==df [#_.sink($1)]
}

// beSOURCE: awful performance due to [[$1, _<, $$, >_]] in IFCOND
IF !(product == "beSOURCE") THEN
// TODO: @checked?
ADD-EXCLUDE "51000789" {
    [#_.source($1)] <--if [[$1, _<, $$, >_]] in IFCOND <==df [#_.sink($1)]
}
ENDIF

//////////////////////////////////////////////////////////////////////////////
// CWE-807 Reliance on Untrusted Inputs in a Security Decision

RULE "51000807" {
    PATTERN {
        UNSAFE AND[
               [gethostbyaddr(...)] <--if [#StrCmp($0, $$)] in IFCOND;
               [#External($1)] <--if [#StrCmp($$, $1)] in IFCOND
        ]
    }

    PATTERN {
        UNSAFE AND[
               [gethostbyaddr(...)] <--if [#StrCmp($0, $$)] in IFCOND;
               [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
         <--if [#RECV($1, $2)] <--if [#StrCmp($$, $2)] in IFCOND
        ]
    }

    PATTERN {
        UNSAFE AND[
               [cgiFormString($$, $1, $$)] <--if [#StrCmp($1, $$)] in IFCOND;
               [#External($1)] <--if [#StrCmp($$, $1)] in IFCOND
        ]
    }

    PATTERN {
        UNSAFE AND[
               [cgiFormString($$, $1, $$)] <--if [#StrCmp($1, $$)] in IFCOND;
               [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
         <--if [#RECV($1, $2)] <--if [#StrCmp($$, $2)] in IFCOND
        ]
    }

    PATTERN {
        UNSAFE [gethostbyaddr(...)] in FUNCTION<decision>
         <--if [#StrCmp($0, $$)] in IFCOND in FUNCTION<decision>
    }
}

//////////////////////////////////////////////////////////////////////////////
// LDAP Manipulation

GROUP #"51009106".source = #External
GROUP #"51009106".sink = #LDAPfunction

GROUP #"51009106".sanitizer($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51009106" {
    UNSAFE  [#_.source($1)] <--if [#_.sink($1,$$)]
    EXCLUDE [#_.source($1)] <--if [#_.sanitizer($1)] <--rf [#_.sink($1,$$)]
}

//RULEID "51009116"
//UNSAFE VSP[SASP, C,9116]

//RULEID "51009117"
//UNSAFE VSP[SASP, C,9117]

//////////////////////////////////////////////////////////////////////////////
// Buffer Overflow (Signed Comparison)

GROUP #UnsignedArgFunc($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(mem\(cmp\|cpy\|move\)\|str\(lcat\|lcpy\|ncat\|ncmp\|ncpy\)\)/($$,$$,$1),
    /\(memset\|strnlen\)/($$,$1)
}

GROUP #"51009118".unsigned = #UnsignedArgFunc

RULE "51009118" {
    UNSAFE [#_.unsigned($<SIGNED>)]
}

// RULEID "51009119"
// UNSAFE VSP[SASP, C,9119]

//////////////////////////////////////////////////////////////////////////////
// Buffer Overflow (Format String (%f/%F))

RULE "51009120" {
    UNSAFE VSP[SASP, C,9120]
}

//////////////////////////////////////////////////////////////////////////////
// Hard-Coded Username

GROUP #DBConU($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(OCILogon2?\|SQLConnect\)/($$, $$, $$, $1, ...),
    mysql_real_connect($$, $$, $1, ...)
}

GROUP #"51009301".username = #DBConU

RULE "51009301" {
    UNSAFE [#_.username($<CONSTANT>)]
}

//////////////////////////////////////////////////////////////////////////////
// Password in Comment

RULE "51009302" = "51000615"

//////////////////////////////////////////////////////////////////////////////
// Weak Cryptographic Hash: Hard-coded Salt

GROUP #Encrypt($1) {
    TEMPLATE #placeholder(..., $1, ...),

    crypt($$, $1)
}

GROUP #"51009307".salt = #Encrypt

RULE "51009307" {
    UNSAFE [#_.salt($<CONSTANT>)]
}

//////////////////////////////////////////////////////////////////////////////
// Weak Encryption: Inadequate RSA Padding

GROUP #RSAEncNP($1) {
    TEMPLATE #placeholder(..., $1, ...),

    RSA_public_encrypt($$, $$, $$, $$, $1)
}

RULE "51009309" {
    PATTERN {
        UNSAFE [#RSAEncNP("RSA_NO_PADDING"<STRING>)]
    }

    PATTERN {
        UNSAFE [ASSIGN($1 := $<NAME RSA_NO_PADDING>)] <--rf [#RSAEncNP($1)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// Weak Encryption: Insufficient Key Size

GROUP #"51009310".blacklist = #InadequateEncrypt

RULE "51009310" {
    UNSAFE [#_.blacklist()]
}

//////////////////////////////////////////////////////////////////////////////
// Improper Synchronization

GROUP #PthreadCondSignal() {
    TEMPLATE #placeholder(...),

    pthread_cond_signal(...)
}

GROUP #"51009407".lock = #PthreadMutexLock
GROUP #"51009407".unlock = #PthreadMutexUnlock
GROUP #"51009407".cond = #PthreadCondSignal

RULE "51009407" {
    UNSAFE  [#_.lock($$)] <--cf [#_.cond()]
    EXCLUDE [#_.unlock($$)] <--cf [#_.cond()]
}

//////////////////////////////////////////////////////////////////////////////
// Format String (Argument Number Mismatch)

RULE "51009607" {
    UNSAFE VSP[SASP, C,9607]
}

//////////////////////////////////////////////////////////////////////////////
// Code Correctness: Arithmetic Operation on Bool

RULE "51009614" {
    UNSAFE VSP[SASP, C,9614]
}

//////////////////////////////////////////////////////////////////////////////
// Code Correctness: Function Not Invoked

RULE "51009615" {
    UNSAFE VSP[SASP, C,9615]
}

// RULEID "51009616"
// UNSAFE VSP[SASP, C,9616]

//////////////////////////////////////////////////////////////////////////////
// Type Mismatch: Integer to Character

RULE "51009617" {
    UNSAFE VSP[SASP, C,9617]
}

//////////////////////////////////////////////////////////////////////////////
// Code Correctness: Macro Misuse

RULE "51009618" {
    PATTERN {
        UNSAFE  [pthread_cleanup_push(...)]
        EXCLUDE [pthread_cleanup_push(...)]  ==>cf [pthread_cleanup_pop(...)]
    }

    PATTERN {
        UNSAFE  [pthread_cleanup_pop(...)]
        EXCLUDE [pthread_cleanup_push(...)]  <==cf [pthread_cleanup_pop(...)]
    }

    PATTERN {
        UNSAFE  [_pthread_cleanup_push(...)]
        EXCLUDE [_pthread_cleanup_push(...)] ==>cf [_pthread_cleanup_pop(...)]
    }

    PATTERN {
        UNSAFE  [_pthread_cleanup_pop(...)]
        EXCLUDE [_pthread_cleanup_push(...)]  <==cf [_pthread_cleanup_pop(...)]
    }
}

// RULEID "51009619"
// UNSAFE VSP[SASP, C,9619]

RULE "51009620" {
    UNSAFE  [pthread_create(...)]
    EXCLUDE [pthread_create($1, ...)]
      ==>rf [/pthread_\(join\|detach\)/($1, ...)]
    EXCLUDE [pthread_attr_setdetachstate($2, $<NAME PTHREAD_CREATE_DETACHED>)]
      <==rf [pthread_create($$, $2, ...)]
    EXCLUDE [pthread_attr_setdetachstate($2, "1"<INT>)]
      <==rf [pthread_create($$, $2, ...)]
}

// GROUP #IsBadXXXPtr() {
//     /IsBad\(Code\|Read\|String\|Write\)Ptr/(...)
// }

// RULE "51009621" {
//     PATTERN {
//         UNSAFE [#IsBadXXXPtr()]
//     }
// }

//////////////////////////////////////////////////////////////////////////////
// Format String (Argument Type Mismatch)

RULE "51009622" {
    UNSAFE VSP[SASP, C,9622]
}

//////////////////////////////////////////////////////////////////////////////
// Memory Leak (Reallocation)

RULE "51009623" {
    UNSAFE [realloc(...)]
}

//////////////////////////////////////////////////////////////////////////////
// CSP
//////////////////////////////////////////////////////////////////////////////

RULE "51008129" {
    UNSAFE VSP[CSP, "buffer_overflow"]
}

RULE "51008369" {
    UNSAFE VSP[CSP, "div_by_zero"]
}

RULE "51008401" {
    UNSAFE VSP[CSP, "leak"]
}

RULE "51008404" {
    UNSAFE VSP[CSP, "free_nonheap"]
}

RULE "51008415" {
    UNSAFE VSP[CSP, "double_free"]
}

RULE "51008416" {
    UNSAFE VSP[CSP, "dang_deref"]
}

RULE "51008457" {
    UNSAFE VSP[CSP, "uninit"]
}

RULE "51008476" {
    UNSAFE VSP[CSP, "null_deref"]
}

RULE "51008562" {
    UNSAFE VSP[CSP, "ret_stack"]
}

CUSTOM "CSP" {{{

////////////////////////////////////////////////////////////////////////
// CSP: Typedefs

typedef unsigned long size_t;
typedef unsigned long rsize_t;
typedef void *locale_t;
typedef unsigned long ssize_t;
typedef void *FILE;

////////////////////////////////////////////////////////////////////////
// CSP: stdlib.h

void *malloc(size_t size) = %malloc(size);
void *realloc(void *ptr, size_t size) = %realloc(ptr, size);
void *alloca(size_t size) = %alloca(size);
void *calloc(size_t n, size_t size) = %calloc(n, size);
void free(void *ptr) = %free(ptr);

int atoi(const char *s) {
    %use_string(s);
    i = %unsafe_int();
    return i;
}

int atoi_l(const char *s, locale_t loc) {
    %use_string(s);
    i = %unsafe_int();
    return i;
}

long atol(const char *s) {
    %use_string(s);
    i = %unsafe_int();
    return i;
}

long atol_l(const char *s, locale_t loc) {
    %use_string(s);
    i = %unsafe_int();
    return i;
}

long long atoll(const char *s) {
    %use_string(s);
    i = %unsafe_int();
    return i;
}

long long atoll_l(const char *s, locale_t loc) {
    %use_string(s);
    i = %unsafe_int();
    return i;
}

int abs(int i) {
    a = %abs(i);
    return a;
}

long long llabs(long long x) {
    a = %abs(x);
    return a;
}

long labs(long x) {
    a = %abs(x);
    return a;
}

double fabs(double x) {
    a = %abs(x);
    return a;
}

long double fabsl(long double x) {
    a = %abs(x);
    return a;
}

float fabsf(float x) {
    a = %abs(x);
    return a;
}

////////////////////////////////////////////////////////////////////////
// CSP: String

char *strcpy(char *restrict dst, const char* restrict src) = %strcpy(dst, src);
char *strncpy(char *restrict dst, const char* restrict src, size_t n)
    = %strncpy(dst, src, n);
void bzero(void *s, size_t n) = %bzero(s, n);
int memcmp(const void *s1, const void *s2, size_t n) = %memcmp(s1, s2, n);
void *memcpy(void *restrict dst, const void *restrict src, size_t n) = %memcpy(dst, src, n);
void *memset(void *s, int c, size_t len) = %memset(s, c, len);
size_t strlen(const char *s) = %strlen(s);
size_t wcslen(const wchar_t *s) = %strlen(s);

char *strpbrk(const char *s, const char *charset) {
    %use_string(s);
    %use_string(charset);
    p = %null_or_string(1);
    return p;
}

wchar_t *wcspbrk(const wchar_t *s, const wchar_t *charset) {
    %use_string(s);
    %use_string(charset);
    p = %null_or_string(1);
    return p;
}

size_t strspn(const char *s, const char *charset) {
    %use_string(s);
    %use_string(charset);
    l = %strlen(s);
    r = %int(0, s);
    return r;
}

size_t strcspn(const char *s, const char *charset) {
    %use_string(s);
    %use_string(charset);
    l = %strlen(s);
    r = %int(0, s);
    return r;
}

size_t wcsspn(const wchar_t *s, const wchar_t *charset) {
    %use_string(s);
    %use_string(charset);
    l = %strlen(s);
    r = %int(0, s);
    return r;
}

size_t wcscspn(const wchar_t *s, const wchar_t *charset) {
    %use_string(s);
    %use_string(charset);
    l = %strlen(s);
    r = %int(0, s);
    return r;
}

////////////////////////////////////////////////////////////////////////
// CSP: stdio.h

int printf(const char* restrict @outfmt fmt, ...) {
    %use_string(fmt);
    %use_string(%vargs);
    %use_fmt_args(fmt, %vargs);
    r = %arbitrary_int();
    return r;
}

int fprintf(FILE *restrict stream, const char* restrict @outfmt fmt, ...) {
    %deref(stream);
    %use_string(fmt);
    %use_string(%vargs);
    %use_fmt_args(fmt, %vargs);
    r = %arbitrary_int();
    return r;
}

int sprintf(char *restrict buf, const char* restrict @outfmt fmt, ...) {
    %deref(buf);
    %use_string(fmt);
    %use_string(%vargs);
    %use_fmt_args(fmt, %vargs);
    l = %fmt_len(fmt, %vargs);
    l = l + 1;
    %update_array(buf, 0, l);
    r = %arbitrary_int();
    return r;
}

int scanf(const char* restrict @infmt fmt, ...) {
    %use_string(fmt);
    %update(%vargs);
    r = %arbitrary_int();
    return r;
}

int sscanf(const char *restrict s, const char* restrict @infmt fmt, ...) {
    %use_string(s);
    %use_string(fmt);
    %update(%vargs);
    r = %arbitrary_int();
    return r;
}

int fscanf(FILE *restrict stream, const char* restrict @infmt fmt, ...) {
    %deref(stream);
    %use_string(fmt);
    %update(%vargs);
    r = %arbitrary_int();
    return r;
}

////////////////////////////////////////////////////////////////////////
// CSP: sys/socket.h

ssize_t recv(int socket, void *buf, size_t len, int flags) {
    %update_array(buf, 0, len);
    r = %arbitrary_int();
    return r;
}

}}}

//////////////////////////////////////////////////////////////////////////////
// ECP
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// CERT-C ARR01-C. Do not apply the sizeof operator to a pointer when taking
// the size of an array

RULE "51003002" {
    UNSAFE VSP[ECP, "sizeof_pointer"]
}

RULE "51003051" {
    UNSAFE VSP[ECP, "arr_idx_out_simple"]
}

RULE "51003072" {
    UNSAFE VSP[ECP, "arr_idx_out_simple"]
    OPTION source = "getenv"
}

RULE "51003170" {
    UNSAFE VSP[ECP, "arr_idx_out_simple"]
    OPTION nonterm = "true"
    OPTION writer = ["strncpy", "strncat", "fgets", "snprintf"]
    OPTION pos = "update"
}

RULE "51003173" {
    UNSAFE VSP[ECP, "arr_idx_out_simple"]
    OPTION string = "true"
    OPTION mode = "write"
}

RULE "51003174" {
    UNSAFE VSP[ECP, "arr_idx_out_simple"]
    OPTION nonterm = "true"
    OPTION pos = "update"
}

RULE "51003087" {
    PATTERN {
        UNSAFE VSP[ECP, "dang_deref_simple"]
        OPTION type = "invalid"
    }
    PATTERN {
        UNSAFE VSP[ECP, "arr_idx_out_simple"]
        OPTION mode = "pointer"
    }
}

RULE "51003342" {
    UNSAFE VSP[ECP, "arr_ptr_arith_simple"]
    OPTION subtraction = "true"
    OPTION comparison = "false"
}

RULE "51003343" {
    UNSAFE VSP[ECP, "arr_ptr_arith_simple"]
    OPTION subtraction = "false"
    OPTION comparison = "true"
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C ARR36-C. Do not subtract or compare two pointers that do not refer
// to the same array

// TODO: Replace with CSP.
RULE "51003055" {
    UNSAFE VSP[ECP, "arr_ptr_arith_simple"]
}

RULE "51003292" {
    UNSAFE VSP[ECP, "dang_deref_simple"]
    OPTION type = "uninit"
}

RULE "51003137" {
    UNSAFE VSP[ECP, "dang_deref_simple"]
    OPTION type = "freed"
}

RULE "51003128" {
    UNSAFE VSP[ECP, "div_by_zero_simple"]
}

RULE "51003138" {
    UNSAFE VSP[ECP, "double_free_simple"]
}

RULE "51003093" {
    UNSAFE VSP[ECP, "null_deref_simple"]
}

RULE "51003109" {
    UNSAFE VSP[ECP, "null_deref_simple"]
    OPTION generator = ["fopen", "gets", "fgets"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C ERR33-C. Detect and handle standard library errors

RULE "51003083" {
    PATTERN {
        UNSAFE VSP[SASP, C, 3083]
        OPTION function = [
            "fopen", "gets", "fgets", "aligned_alloc",
            "bsearch", "bsearch_s", "calloc", "freopen",
            "getenv", "getenv_s", "gets_s", "gmtime", "gmtime_s",
            "realloc", "localtime", "localtime_s", "malloc", "memchr",
            "setlocale", "strchr", "strpbrk", "strrchr", "strstr",
            "strtok", "strtok_s", "tmpfile", "tmpnam", "wcschr",
            "wcspbrk", "wcsrchr", "wcsstr", "wcstok", "wcstok_s",
            "wmemchr", "fmemopen", "open_memstream", "posix_memalign",
            "fseek", "snprintf"
        ]
    }

    // p = relloc(p, ...)
    PATTERN {
        UNSAFE VSP[SASP, C, 3864]
    }
}

RULE "51003865" = "51003083"

//////////////////////////////////////////////////////////////////////////////
// BSSC 66: A function may not return a reference or pointer to one of its own
// local automatic variables.

// TODO: Replace with CSP.
RULE "51003857" {
    PATTERN {
        // UNSAFE VSP[ECP, "ret_stack_addr_simple"]
        UNSAFE VSP[ECP, "unit"]
    }
    PATTERN {
        // UNSAFE VSP[ECP, "out_of_scope_obj_simple"]
        UNSAFE VSP[ECP, "unit"]
    }
}

RULE "51003068" = "51003857"

//////////////////////////////////////////////////////////////////////////////
// BSSC 100: Dynamic memory allocated using malloc() should be returned to the
// system using free().

RULE "51003863" {
    UNSAFE VSP[ECP, "malloc_free"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C MSC07-C. Detect and remove dead code

RULE "51003143" {
    UNSAFE VSP[ECP, "dead_code_simple"]
}

RULE "51003531" = "51003143"

RULE "51003136" {
    UNSAFE VSP[ECP, "leak_on_return_simple"]
}

RULE "51003122" {
    UNSAFE VSP[ECP, "negative_in_mod_simple"]
    OPTION hotspot = "array"
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO37-C. Do not assume that fgets() or fgetws() returns a nonempty
// string when successful

RULE "51003111" {
    UNSAFE VSP[ECP, "assume_ret_nonemp_string_simple"]
    OPTION function = "fgets"
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C MEM04-C. Do not perform zero length allocations

RULE "51003132" {
    PATTERN {
        UNSAFE VSP[ECP, "validate_param_simple"]
        OPTION function = ["malloc"]
        OPTION arg = 0
        OPTION invalid = 0
    }

    PATTERN {
        UNSAFE VSP[ECP, "validate_param_simple"]
        OPTION function = ["realloc", "calloc"]
        OPTION arg = 1
        OPTION invalid = 0
    }
}

RULE "51003139" {
    UNSAFE VSP[ECP, "free_nonheap_simple"]
}

RULE "51003348" {
    UNSAFE VSP[ECP, "restricted_ptr_simple"]
}

RULE "51003069" = "51003348"

RULE "51003151" {
    UNSAFE VSP[ECP, "validate_tm_simple"]
    OPTION function = "asctime"
}

RULE "51003154" {
    UNSAFE VSP[ECP, "emp_inf_loop_simple"]
    OPTION exclude_literal = "true"
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C DCL07-C. Include the appropriate type information in function
// declarators

RULE "51003003" {
    UNSAFE VSP[ECP, "func_arity_check_type"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C DCL10-C. Maintain the contract between the writer and caller of
// variadic functions

RULE "51003004" {
    UNSAFE VSP[ECP, "vfunc_check"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C DCL11-C. Understand the type issues associated with variadic
// functions

RULE "51003005" {
    UNSAFE VSP[ECP, "type_variadic_func"]
    OPTION ignore_unknown_type = "false"
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C DCL40-C. Declare objects with appropriate storage durations

RULE "51003007" {
    UNSAFE VSP[ECP, "typ_chk_extern"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C EXP01-C. Do not take the size of a pointer to determine the size of
// the pointed-to type

RULE "51003008" {
    UNSAFE VSP[ECP, "sizeof_pointer_check"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C EXP04-C. Do not perform byte-by-byte comparisons involving
// a structure

RULE "51003009" {
    UNSAFE VSP[ECP, "memcmp_struct_pointer"]
    OPTION aggregate = "true"
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C EXP05-C. Do not cast away a const qualification

RULE "51003010" {
    UNSAFE VSP[ECP, "const_casting"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C EXP16-C. Do not compare function pointers to constant values

RULE "51003011" {
    UNSAFE VSP[ECP, "boolean_funcptr"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C EXP20-C. Perform explicit tests to determine success, true
// and false, and equality.

RULE "51003013" {
    UNSAFE VSP[ECP, "explicit_test_for_func"]
    OPTION zerotest = "true"
    OPTION exclude = ["signal", "fputs", "puts", "ungetc", "putc", "scanf"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C EXP32-C. Do not access a volatile object through a nonvolatile
// reference

RULE "51003014" {
    UNSAFE VSP[ECP, "volatile_to_nonvol_chk"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO00-C. Take care when creating format strings

RULE "51003017" {
    UNSAFE VSP[ECP, "type_variadic_func"]
    OPTION ignore_unknown_type = "false"
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO09-C. Be careful with binary data when transferring data across
// systems

RULE "51003018" {
    UNSAFE VSP[ECP, "fread_struct_pointer"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO34-C. Use int to capture the return value of character IO
// functions

RULE "51003019" {
    UNSAFE VSP[ECP, "char_capture_char_io_fun"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO38-C. Do not use a copy of a FILE object

RULE "51003020" {
    UNSAFE VSP[ECP, "copy_file_object"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FLP02-C. Avoid using floating point numbers when precise
// computation is needed.

RULE "51003021" {
    UNSAFE VSP[ECP, "float_equality"]
    OPTION mode = "general"
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FLP03-C. Detect and handle floating point errors

RULE "51003022" {
    UNSAFE VSP[ECP, "float_func"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FLP06-C. Understand that floating-point arithmetic in C is inexact.

RULE "51003023" {
    UNSAFE VSP[ECP, "float_equality"]
    OPTION mode = "general"
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FLP30-C. Don't use float as loop counter

RULE "51003024" {
    UNSAFE VSP[ECP, "loop_float"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FLP31-C. Do not call functions expecting real values with complex
// values.

RULE "51003025" {
    UNSAFE VSP[ECP, "complex_incompatible_func"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FLP33-C. Convert integers to floating point for floating point
// operations

RULE "51003026" {
    UNSAFE [ASSIGN($<FLOAT> := ($<INT>, [+, -, /, *], $<INT>))]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C INT00-C. Understand the data model used by your implementation(s)

RULE "51003027" {
    UNSAFE VSP[ECP, "int_data_model"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C INT01-C. Use rsize_t or size_t for all integer values representing
// the size of an object.

RULE "51003028" {
    UNSAFE VSP[ECP, "sizeof_param_typ_chk"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C INT02-C. Understand integer conversion rules

RULE "51003029" {
    UNSAFE VSP[ECP, "understand_integer"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C INT07-C. Use only explicitly signed or unsigned char type for
// numeric values

RULE "51003030" {
    UNSAFE VSP[SASP, C, 3030]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C INT12-C. Do not make assumptions about the type of a plain int
// bit-field when used in an expression

RULE "51003031" {
    UNSAFE VSP[ECP, "bitfld_typ_assumption_chk"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C INT13-C. Use bitwise operators only on unsigned operands.

RULE "51003032" {
    UNSAFE VSP[ECP, "only_uint_bitwise"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C INT15-C. Use intmax_t or uintmax_t for formatted IO on
// programmer-defined integer types

RULE "51003033" {
    UNSAFE VSP[ECP, "printf_typ_casting_chk"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C INT35-C. Evaluate integer expressions in a larger size before
// comparing or assigning to that size

RULE "51003034" {
    UNSAFE VSP[ECP, "smaller_type"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C MEM02-C. Immediately cast the result of a memory allocation
// function call into a pointer to the allocated type

RULE "51003035" {
    UNSAFE VSP[ECP, "typ_chk_malloc"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C MEM08-C. Use realloc() only to resize dynamically allocated arrays

RULE "51003036" {
    UNSAFE VSP[ECP, "typ_chk_realloc"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C MEM33-C. Allocate and copy structures containing flexible array
// members dynamically

RULE "51003037" {
    UNSAFE VSP[ECP, "flexible_arr_alloc_chk"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C MSC05-C. Do not manipulate time_t typed values directly.

RULE "51003038" {
    UNSAFE VSP[ECP, "direct_time_manipulation"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C MSC19-C. For functions that return an array, prefer returning
// an empty array over a null value.

RULE "51003040" {
    UNSAFE VSP[ECP, "arrfun_null"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C MSC31-C. Ensure that return values are compared against the proper
// type

RULE "51003041" {
    UNSAFE VSP[SASP, C, 3041]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C POS34-C. Do not call putenv() with a pointer to an automatic
// variable as the argument

RULE "51003042" {
    UNSAFE VSP[ECP, "putenv_static"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C STR04-C. Use plain char for characters in the basic character set

RULE "51003043" {
    UNSAFE VSP[ECP, "string_assign_to_non_plain_chars"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C STR09-C. Don't assume numeric values for expressions with type
// plain characte

RULE "51003044" {
    UNSAFE VSP[ECP, "char_compare"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C STR33-C. Size wide character strings correctly

RULE "51003045" {
    UNSAFE VSP[ECP, "string_correctly"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C STR34-C. Cast characters to unsigned char before converting to
// larger integer sizes

RULE "51003046" {
    UNSAFE VSP[ECP, "char_int_assign_missing_unsigned_cast"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C STR37-C. Arguments to character handling functions must be
// representable as an unsigned char

RULE "51003047" {
    UNSAFE VSP[ECP, "args_unsigned_char"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C STR38-C. Do not use wide-char functions on narrow-char strings
// and vice versa

RULE "51003048" {
    UNSAFE VSP[ECP, "char_wchar_mix"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C ARR32-C. Ensure size arguments for variable length arrays are in
// a valid range

RULE "51003052" {
    UNSAFE VSP[ECP, "arr_valid_range"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C CON02-C. Do not use volatile as a synchronization primitive.

RULE "51003060" {
    UNSAFE VSP[ECP, "volatile_sync"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C CON33-C. Avoid race conditions when using library functions.

RULE "51003063" {
    UNSAFE VSP[ECP, "forbidden_fcall"]
    OPTION function = [
        "rand", "srand", "getenv", "getenv_s", "strtok", "strerror",
        "asctime", "ctime", "localtime", "gmtime", "setlocale",
        "ATOMIC_VAR_INIT", "atom_init", "tmpnam",
        "mbrtoc16", "mbrtoc32", "c16rtomb", "c32rtomb"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C CON05-C. Do not perform operations that can block while holding
// a lock.

GROUP #BlockingOperation() {
    TEMPLATE #placeholder(..., $1, ...),

    /f.*open\|fclose\|fread\|fwrite/(...)
}

RULE "51003065" {
    UNSAFE  [#MutexLock($$)] <--cf [#BlockingOperation()]
    EXCLUDE [#MutexLock($1)] <--if [#MutexUnlock($1)] <--cf [#BlockingOperation()]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C DCL13-C. Declare function parameters that are pointers to values
// not changed by the function as const

RULE "51003067" {
    UNSAFE VSP[ECP, "const_param"]
    OPTION dest = "pointer"
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C DCL34-C. Use volatile for data that cannot be cached

RULE "51003070" {
    UNSAFE VSP[ECP, "global_in_handlers"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C ENV00-C. Do not store the pointer to the string returned by getenv()

RULE "51003071" {
    UNSAFE VSP[ECP, "getenv_store"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C ENV31-C. Do not rely on an environment pointer following
// an operation that may invalidate it

RULE "51003076" {
    PATTERN {
        UNSAFE [setenv(...)] <--cf [$<NAME envp>] in FUNCTION<main>
    }
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C ENV32-C. All atexit handlers must return normally

RULE "51003077" {
    UNSAFE VSP[ECP, "atexit_abnormal_termination"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C ERR01-C. Use ferror() rather than errno to check for FILE stream
// errors

RULE "51003078" {
    UNSAFE VSP[ECP, "stdio_errno"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C ERR06-C. Understand the termination behavior of assert() and abort()

RULE "51003080" {
    UNSAFE VSP[ECP, "atexit_assert"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C ERR30-C. Set errno to zero before calling a library function known
// to set errno, and check errno only after the function returns a value
// indicating failure

RULE "51003081" {
    UNSAFE VSP[ECP, "errno_func_check"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C EXP02-C. Be aware of the short-circuit behavior of the logical
// AND and OR operators

RULE "51003084" {
    UNSAFE VSP[ECP, "logical_op_sideeffect"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C EXP03-C. Do not assume the size of a structure is the sum of
// the sizes of its members

RULE "51003085" {
    UNSAFE VSP[ECP, "strct_padding_size_chk"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C EXP06-C. Operands to the sizeof operator should not contain
// side effects

RULE "51003086" {
    UNSAFE VSP[ECP, "operand_sideeffect"]
    OPTION rule = "CERT"
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C EXP10-C. Do not depend on the order of evaluation of subexpressions
// or the order in which side effects take place

RULE "51003088" {
    UNSAFE VSP[ECP, "double_sideeffect_exp_fast"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C EXP11-C. Do not make assumptions regarding the layout of structures
// with bit-fields

RULE "51003089" {
    UNSAFE VSP[ECP, "bitfield_align"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C EXP30-C. Do not depend on order of evaluation between sequence
// points.

RULE "51003090" {
    UNSAFE VSP[ECP, "depend_order"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C EXP31-C. Avoid side effects in assertions

RULE "51003091" {
    UNSAFE VSP[ECP, "funparam_sideeffect"]
    OPTION target = "assert"
}

RULE "51003092" = "51003524"

//////////////////////////////////////////////////////////////////////////////
// CERT-C EXP36-C. Do not convert pointers into more strictly aligned
// pointer types

RULE "51003095" {
    UNSAFE VSP[SASP, C, 3095]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C EXP39-C. Do not access a variable through a pointer of
// an incompatible type

RULE "51003096" {
    PATTERN {
        UNSAFE VSP[ECP, "incompatible_ptr"]
    }

    PATTERN {
        UNSAFE  [malloc($$):$1] -->if [realloc($1, $$)] -->if [free($1)]
        EXCLUDE [malloc($$):$1] -->if [realloc($1, $$):$2] -->if [free($1)]
          -->if [memset($2, ...)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C ARR39-C. Do not add or subtract a scaled integer to a pointer.

RULE "51003097" {
    UNSAFE VSP[SASP, C, 3097]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO01-C. Be careful using functions that use file names for
// identification

RULE "51003098" {
    UNSAFE [fopen($1, $$)] <--if [/remove\|chown\|stat\|chmod/($1, ...)]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO02-C. Canonicalize path names originating from untrusted sources

RULE "51003099" {
    UNSAFE  [#External($1)] <--if [fopen($1, $$)]
    EXCLUDE [#External($1)]
      <--if [realpath($1, $<null OR LIT "NULL" OR LIT "0">):$2]
      <--if [fopen($2, $$)]
    EXCLUDE [#External($1)]
      <--if [$2<NAME PATH_MAX>]
      <--if [realpath($1, $2):$3]
      <--if [fopen($3, $$)]
    EXCLUDE [#External($1)]
      <--if [canonicalize_file_name($1):$2]
      <--if [fopen($2, $$)]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO05-C. Identify files using multiple file attributes

RULE "51003100" {
    UNSAFE  [/fopen\|open/($1, ...)] <--if [/fopen\|open/($1, ...)]
    EXCLUDE [/fopen\|open/($1, ...):$2]
      <--if [fstat($2, $$)]
      <--if [/fopen\|open/($1, ...)]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO08-C. Take care when calling remove() on an open file

RULE "51003101" {
    UNSAFE  [fopen($1, ...)] <--if [remove($1)]
    EXCLUDE [fopen($1, ...):$2] <--if [fclose($2)] <--if [remove($1)]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO13-C. Never push back anything other than one read character

RULE "51003102" {
    UNSAFE [fopen($$, $$):$1] <--if [ungetc($$, $1)] <--if [ungetc($$, $1)]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO18-C. Never expect fwrite() to terminate the writing process at
// a null character

RULE "51003104" {
    UNSAFE  [fwrite($$, $<LIT "1", INT>, $<NONCONSTANT>, $$)]
    EXCLUDE [strlen($1):$2]
      <--if [fwrite($1, $<LIT "1", INT>, $2, $$)]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO19-C. Do not use fseek() and ftell() to compute the size of
// a file

RULE "51003105" {
    UNSAFE AND[[fopen($$, $$):$1] <--if [fseek($1, $$, $$)] <--if [ftell($1)];
               [ftell($$):$1] -->if [#UnsignedAllocFunc($1)]]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO30-C. Exclude user input from format strings

GROUP #"51003106".* = #"51000134".*
RULE "51003106" = "51000134"

//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO31-C. Do not open a file that is already open

RULE "51003107" {
    PATTERN {
        UNSAFE  [fopen($1, $$)] <--if [fopen($1, $$)]
        EXCLUDE [fopen($1, $$):$2] <--if [fclose($2)] <--if [fopen($1, $$)]
    }

    // TODO: New RDL feature, code matching should be introduced.
    // PATTERN {
    //     UNSAFE  [fopen(%1<LIT>, $$)] <--cf [fopen(%1, $$)]
    //     EXCLUDE [fopen(%1<LIT>, $$):$2] <--if [fclose($2)] <--if [fopen(%1, $$)]
    // }
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO32-C. Do not perform operations on devices that are only
// appropriate for files

RULE "51003108" {
    UNSAFE VSP[ECP, "lstat_open_fstat"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO36-C. Do not assume a newline character is read when using
// fgets()

RULE "51003110" {
    UNSAFE [fgets($1, ...)] <--rf [strlen($1)]
     <--if [($1, -, $<LIT "1", INT>)]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO39-C. Do not alternately input and output from a stream without
// an intervening flush or positioning call

RULE "51003112" {
    PATTERN {
        UNSAFE  [fopen($$, $$):$1] <--if [fwrite(..., $1)] <--if [fread(..., $1)]
        EXCLUDE [fopen($$, $$):$1] <--if [fwrite(..., $1)]
          <--if [/fflush\|fseek\|fsetpos\|rewind/(..., $1, ...)]
          <--if [fread(..., $1)]
    }

    PATTERN {
        UNSAFE  [fopen($$, $$):$1] <--if [fread(..., $1)] <--if [fwrite(..., $1)]
        EXCLUDE [fopen($$, $$):$1] <--if [fread(..., $1)]
          <--if [/fseek\|fsetpos\|rewind/(..., $1, ...)]
          <--if [fwrite(..., $1)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO40-C. Reset strings on fgets() failure

RULE "51003113" {
    UNSAFE VSP[ECP, "missing_reset_fgets_failure"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO41-C. Do not call getc() or putc() with stream arguments that
// have side effects

RULE "51003114" {
    UNSAFE VSP[ECP, "funparam_sideeffect"]
    OPTION target = "getputc"
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO42-C. Ensure files are properly closed when they are no longer
// needed

RULE "51003115" {
    PATTERN {
        UNSAFE  [fopen($$, $$)] -->if [/system\|fork\|exec/(...)]
        EXCLUDE [fopen($$, $$):$1] -->if [fclose($1)]
          -->if [/system\|fork\|exec/(...)]
    }

    PATTERN {
        UNSAFE  [open($$, $$)] -->if [/system\|fork\|exec/(...)]
        EXCLUDE [open($$, $$):$1] -->if [close($1)]
          -->if [/system\|fork\|exec/(...)]
        EXCLUDE [open($$, $$):$1]
          -->if [$2<NAME FD_CLOEXEC>]
          -->if [fcntl($1, $<NAME F_SETFD>, $2)]
          -->if [/system\|fork\|exec/(...)]
        EXCLUDE [$1<NAME O_CLOEXEC>]
          <--if [open($$, $1)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO44-C. Only use values for fsetpos() that are returned from
// fgetpos()

RULE "51003116" {
    UNSAFE  [fsetpos($$, $$)]
    EXCLUDE [fgetpos($$, $1)] <--if [fsetpos($$, $1)]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FLP04-C. Check floating-point inputs for exceptional values

// FIXME: must consider type of parameter, not format string.
// FIXME: replace CF with data-flow

GROUP #FormatInput($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /v?scanf/($1, ...),
    /\(f\|s\|vf\|vs\)scanf/($$, $1, ...),
    /v?snscanf/($$, $$, $1, ...),
    /v?cbscanf/($$, $$, $$, $1, ...)
}

GROUP #"51003117".source = #FormatInput

RULE "51003117" {
    UNSAFE  [#_.source($<LIT {{.*%l?f.*}}>)]
    EXCLUDE AND[[#_.source($<LIT {{.*%l?f.*}}>)] -->cf [isinf($$)];
                [#_.source($<LIT {{.*%l?f.*}}>)] -->cf [isnan($$)]]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C INT04-C. Enforce limits on integer values originating from tainted
// sources

RULE "51003119" {
    PATTERN {
        UNSAFE  [#External($1)] <--if [#UnsignedAllocFunc($1)]
        EXCLUDE [#External($1)]
          <--if [($1<INT OR CHAR>, >_<, $<NAME /MAX_.*/>)]
          <--if [#UnsignedAllocFunc($1)]
    }

    PATTERN {
        UNSAFE  [#External($1)] <--if [$1] in ARRAYINDEX
        EXCLUDE [#External($1)]
          <--if [($1<INT OR CHAR>, >_<, $<NAME /MAX_.*/>)]
          <--if [$1] in ARRAYINDEX
    }
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C INT05-C. Do not use input functions to convert character data if
// they cannot handle all possible inputs

GROUP #FormatInputVal($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /v?scanf/($$, ..., $1, ...),
    /\(f\|s\|vf\|vs\)scanf/($$, $$, ..., $1, ...),
    /v?snscanf/($$, $$, $$, ..., $1, ...),
    /v?cbscanf/($$, $$, $$, $$, ..., $1, ...)
}

GROUP #StringToInt() {
    /strtol\|strtoll\|strtoimax\|strtoul\|strtoull\|strtoumax/(...)
}

RULE "51003120" {
    // $1<INT> cause poor performance.
    // If #_source($1<POINTER INT>) is possible...
    PATTERN {
        UNSAFE  [$1<INT>] //@pragma(allow_vague)
          <--if [#FormatInputVal($1)]
        EXCLUDE [#FormatInputVal($$)]
          -->cf [[$<NAME errno>, _=, $<NAME ERANGE>, _=]]
    }

    PATTERN {
        UNSAFE  [#StringToInt()]
        EXCLUDE [#StringToInt()]
          -->cf [[$<NAME errno>, _=, $<NAME ERANGE>, _=]]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C INT11-C. Converting a pointer to integer or integer to pointer

RULE "51003123" {
    UNSAFE VSP[ECP, "int_ptr_conv"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C INT14-C. Avoid performing bitwise and arithmetic operations on the
// same data.

RULE "51003124" {
    UNSAFE VSP[SASP, C, 3124]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C MEM00-C. Allocate and free memory in the same module, at the same
// level of abstraction

RULE "51003130" {
    UNSAFE VSP[SASP, C, 3130]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C MEM01-C. Store a valid value in pointers immediately after
// deallocation

RULE "51003131" {
    UNSAFE VSP[SASP, C, 3131]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C MEM07-C. Ensure that the arguments to calloc(), when multiplied, do
// not wrap

RULE "51003133" {
    UNSAFE VSP[SASP, C, 3133]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C MEM09-C. Do not assume memory allocation functions initialize memory

RULE "51003134" {
    UNSAFE  [malloc($$):$1] <--if [strncpy($1, $$, $$)]
    EXCLUDE [strncpy($1, $$, $$)] -->if [ASSIGN($1 := $<LIT "0" OR LIT "\0">)]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C MSC01-C. Strive for logical completeness

RULE "51003141" {
    UNSAFE VSP[ECP, "strange_if_switch"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C MSC06-C. Be aware of compiler optimization when dealing with
// sensitive data

RULE "51003142" {
    UNSAFE VSP[ECP, "memset_optimize"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C MSC09-C. Character Encoding - Use Subset of ASCII for safety

RULE "51003144" {
    UNSAFE VSP[ECP, "fopen_name"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C MSC11-C. Incorporate diagnostic tests using assertions

RULE "51003145" {
    UNSAFE VSP[ECP, "malloc_assert"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C MSC13-C. Detect and remove unused values

// FIXME: Duplicated with CWE-563 Unused Variable 51000563
RULE "51003146" {
    UNSAFE VSP[SASP, C, 563]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C MSC21-C. Use robust loop termination conditions

RULE "51003148" {
    UNSAFE VSP[ECP, "loop_termination_chk"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C MSC32-C. Ensure your random number generator is properly seeded

RULE "51003150" {
    UNSAFE VSP[ECP, "rand_srand"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C MSC37-C. Ensure that control never reaches the end of a non-void
// function

RULE "51003152" {
    UNSAFE VSP[ECP, "nonvoid_func_return"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C POS01-C. Check for the existence of links when dealing with files

RULE "51003155" {
    UNSAFE VSP[ECP, "lstat_open_fstat"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C POS35-C. Avoid race conditions while checking for the existence of a
// symbolic link

RULE "51003157" {
    UNSAFE VSP[ECP, "lstat_open_fstat"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C POS36-C. Observe correct revocation order while relinquishing
// privileges

RULE "51003158" {
    UNSAFE  [getuid():$1] <--df [setuid($1)]
    EXCLUDE [getgid():$1] <--df [setgid($1)] <--cf [setuid($$)]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C POS39-C. Use the correct byte ordering when transferring data
// between systems

RULE "51003161" {
    PATTERN {
        UNSAFE  [/recv\|recvfrom/($$, $$, ...)]
        EXCLUDE [/recv\|recvfrom/($$, $1, ...)] -->if [/ntoh[ls]/($1)]
    }

    PATTERN {
        UNSAFE  [/send\|sendto/($$, $$, ...)]
        EXCLUDE [/hton[ls]/($1)] <--if [/send\|sendto/($$, $1, ...)]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C POS53-C. Do not use more than one mutex for concurrent waiting
// operations on a condition variable with POSIX threads

RULE "51003162" {
    UNSAFE VSP[ECP, "cv_with_multiple_mutex"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C SIG00-C. Mask signals handled by noninterruptible signal handlers

RULE "51003163" {
    UNSAFE VSP[ECP, "handlers_multi"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C SIG01-C. Understand implementation-specific details regarding signal
// handler persistence

RULE "51003164" {
    UNSAFE VSP[ECP, "signal_handler"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C SIG30-C. Call only asynchronous-safe functions within signal
// handlers

RULE "51003165" {
    UNSAFE VSP[ECP, "signal_handlers_functions"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C SIG31-C. Do not access shared objects in signal handlers

RULE "51003166" {
    UNSAFE VSP[ECP, "global_in_handlers"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C SIG34-C. Do not call signal() from within interruptible signal
// handlers

RULE "51003167" {
    UNSAFE VSP[ECP, "signal_in_handler"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C SIG35-C. Do not return from SIGSEGV, SIGILL, or SIGFPE signal
// handlers

RULE "51003168" {
    UNSAFE VSP[ECP, "signal_abort"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C STR02-C. Sanitize data passed to complex subsystems

RULE "51003169" {
    UNSAFE VSP[ECP, "sanitize_data_to_subsystem"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C STR06-C. Do not assume that strtok() leaves the parse string
// unchanged

RULE "51003171" {
    UNSAFE VSP[ECP, "use_of_strtok_chk"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C STR30-C. Do not attempt to modify string literals

RULE "51003172" {
    UNSAFE VSP[ECP, "modify_string_literals"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C STR35-C. Do not copy data from an unbounded source to a fixed-length
// array

RULE "51003175" {
    PATTERN {
        UNSAFE VSP[ECP, "forbidden_fcall"]
        OPTION function = ["gets"]
    }

    PATTERN {
        UNSAFE VSP[ECP, "unbound_scanf"]
    }
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C MSC02-C. Avoid errors of omission

RULE "51003178" {
    UNSAFE VSP[ECP, "error_omission"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C SIG32-C. Do not call longjmp() from inside a signal handler

RULE "51003185" {
    UNSAFE VSP[ECP, "signal_handlers_raise"]
    OPTION mode = "longjmp"
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C SIG33-C. Do not recursively invoke the raise() function

RULE "51003186" {
    UNSAFE VSP[ECP, "signal_handlers_raise"]
    OPTION mode = "raise"
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C PRE31-C. Do not perform side effects in arguments to unsafe macros

RULE "51003187" {
    UNSAFE VSP[ECP, "macro_sideeffect"]
    OPTION mode = "fast"
    OPTION target = "unsafe"
}

//////////////////////////////////////////////////////////////////////////////
// MISRA-C 2004 11-5 (required): A cast shall not be performed that removes
// any const or volatile qualification from the type addressed by a pointer

RULE "51003310" {
    UNSAFE VSP[ECP, "vol_con_pointer_chk"]
}

//////////////////////////////////////////////////////////////////////////////
// MISRA-C 2004 12-7 Bitwise operators shall not be applied to operands whose
// underlying type is signed.

RULE "51003313" {
    UNSAFE VSP[ECP, "bitop_signed"]
}

//////////////////////////////////////////////////////////////////////////////
// MISRA-C 2004 12-9 (required): The unary minus operator shall not be applied
// to an expression whose underlying type is unsigned.

RULE "51003314" {
    UNSAFE VSP[ECP, "uminus_unsigned"]
}

//////////////////////////////////////////////////////////////////////////////
// MISRA-C 2004 13-1 Assignment operators shall not be used in expressions
// that yield a Boolean value.

RULE "51003315" {
    UNSAFE VSP[ECP, "no_assign_in_bool_expr"]
}

//////////////////////////////////////////////////////////////////////////////
// MISRA-C 2004 13-4 (required): The controlling expression of a for statement
// shall not contain any objects of floating type.

RULE "51003318" {
    UNSAFE VSP[ECP, "for_float"]
}

//////////////////////////////////////////////////////////////////////////////
// MISRA-C 2004 6-1 (required): The plain char type shall only be used for the
// storage and use of character values.

RULE "51003324" {
    UNSAFE VSP[ECP, "char_nonplain_char_assign"]
}

//////////////////////////////////////////////////////////////////////////////
// MISRA-C 2004 6-2 (required): signed and unsigned char type shall be used
// only for the storage and use of numeric values.

RULE "51003325" {
    UNSAFE VSP[ECP, "char_nonplain_char_assign"]
}

//////////////////////////////////////////////////////////////////////////////
// MISRA-C 2004 8-3 (required): For each function parameter the type given in
// the declaration and definition shall be identical, and the return types
// shall also be identical.

RULE "51003328" {
    UNSAFE VSP[ECP, "func_proto_dec_check"]
}

//////////////////////////////////////////////////////////////////////////////
// MISRA-C 2004 8-4 (required): If objects or functions are declared more than
// once their types shall be compatible.

RULE "51003329" {
    UNSAFE VSP[ECP, "compatible_declaration"]
}

//////////////////////////////////////////////////////////////////////////////
// MISRA-C 2004 12-2 (required): The value of an expression shall be the same
// under any order of evaluation that the standard permits.

RULE "51003331" {
    UNSAFE VSP[ECP, "subexpression_sideeffect"]
    OPTION mode = "fast"
}

//////////////////////////////////////////////////////////////////////////////
// MISRA-C 2004 12-3 (required): The sizeof operator shall not be used on
// expressions that contain side effects.

RULE "51003332" {
    UNSAFE VSP[ECP, "operand_sideeffect"]
    OPTION mode = "fast"
    OPTION rule = "CERT"
}

//////////////////////////////////////////////////////////////////////////////
// MISRA-C 2004 12-4 (required): The right-hand operand of a logical && or ||
// operator shall not contain side effects.

RULE "51003333" {
    UNSAFE VSP[ECP, "logical_op_sideeffect"]
    OPTION mode = "fast"
}

//////////////////////////////////////////////////////////////////////////////
// MISRA-C 2004 8-11 (required): The static storage class specifier shall be
// used in definitions and declarations of objects and functions that have
// internal linkage.

RULE "51003357" {
    UNSAFE VSP[ECP, "internal_external_linkage_identifiers"]
    OPTION both = "true"
    OPTION internal = "false"
}

RULE "51003334" {
    UNSAFE VSP[ECP, "shift_simple"]
}

RULE "51003526" = "51003334"
RULE "51003129" = "51003334"

//////////////////////////////////////////////////////////////////////////////
// MISRA-C 2004 13-6 (required): Numeric variables being used within a for
// loop for iteration counting shall not be modified in the body of the loop.

RULE "51003335" {
    UNSAFE VSP[ECP, "sentry_sideeffect"]
    OPTION mode = "fast"
}

//////////////////////////////////////////////////////////////////////////////
// MISRA-C 2004 14-2 (required): All non-null statements shall either (a) have
// at least one side-effect however executed, or (b) cause control flow to
// change.

RULE "51003338" {
    UNSAFE VSP[ECP, "non_null_statement"]
    OPTION mode = "fast"
}

//////////////////////////////////////////////////////////////////////////////
// MISRA-C 2004 16-7 (advisory): A pointer parameter in a function prototype
// should be declared as pointer to const if the pointer is not used to modify
// the addressed object.

RULE "51003341" {
    UNSAFE VSP[ECP, "const_param"]
    OPTION mode = "fast"
    OPTION dest = "pointer"
}

//////////////////////////////////////////////////////////////////////////////
// HIS.14 The type char shall always be declared as unsigned char or signed
// char.

RULE "51003501" {
    UNSAFE VSP[ECP, "declare_plainchar"]
}

//////////////////////////////////////////////////////////////////////////////
// HIS.16 The underlaying bit representations of floating point numbers shall
// not be used in any way by the programmer.

RULE "51003502" {
    UNSAFE VSP[ECP, "bit_for_float"]
}

//////////////////////////////////////////////////////////////////////////////
// HIS.26 If objects or functions are declared more than once they shall have
// compatible declarations.

RULE "51003503" {
    UNSAFE VSP[ECP, "compatible_declaration"]
}

//////////////////////////////////////////////////////////////////////////////
// HIS.29 The use of a tag shall agree with its declaration.

RULE "51003504" {
    UNSAFE VSP[ECP, "unit"]
    // FIXME: struct_tag_name_chk
}

//////////////////////////////////////////////////////////////////////////////
// HIS.24 Identifiers shall not simultaneously have both internal and external
// linkage in the same translation unit

RULE "51003546" {
    UNSAFE VSP[ECP, "internal_external_linkage_identifiers"]
    OPTION both = "false"
    OPTION internal = "true"
}

//////////////////////////////////////////////////////////////////////////////
// HIS.23 All declarations at file scope should be static where possible.

RULE "51003547" {
    UNSAFE VSP[ECP, "unit"]
    // ANALYZER ecp_non_static_variables
}

//////////////////////////////////////////////////////////////////////////////
// HIS.25 FIXME

RULE "51003548" {
    UNSAFE VSP[ECP, "external_linkages"]
    OPTION none = "true"
    OPTION more = "false"
}

//////////////////////////////////////////////////////////////////////////////
// HIS.27 An external object or function shall be declared in one and only one
// file.

RULE "51003549" {
    UNSAFE VSP[ECP, "external_linkages"]
    OPTION none = "false"
    OPTION more = "true"
}

//////////////////////////////////////////////////////////////////////////////
// BSSC.118 The programmer may not assume that different data types have
// equivalent representations in memory.

RULE "51003852" {
    UNSAFE VSP[ECP, "memcmp_struct_pointer"]
    OPTION different = "true"
}

//////////////////////////////////////////////////////////////////////////////
// BSSC.120 The programmer may not assume that pointers to different data
// types are equivalent.

RULE "51003853" {
    UNSAFE VSP[ECP, "cast_pointer"]
    OPTION mode = "basic"
}

//////////////////////////////////////////////////////////////////////////////
// BSSC.121 The programmer may not mix pointer and integer arithmetic.

RULE "51003854" {
    UNSAFE VSP[ECP, "pointer_not_int"]
}

//////////////////////////////////////////////////////////////////////////////
// BSSC.122 The programmer must use a wider type or unsigned values when
// testing for underflow or overflow.

RULE "51003855" {
    UNSAFE VSP[ECP, "not_large_type_under_over_check"]
}

//////////////////////////////////////////////////////////////////////////////
// BSSC.93 The programmer shall make sure that the order of evaluation of the
// expression is defined by typing in the appropriate syntax

// TODO: It depends on Ecp_cdfg. Migrate to SASP.
RULE "51003861" {
    UNSAFE VSP[ECP, "depend_order"]
}

//////////////////////////////////////////////////////////////////////////////
// BSSC.99 The return values of memory handling routines must always be
// checked.

// It is subset of CERT-C ERR33-C (51003083).
RULE "51003862" {
    PATTERN {
        UNSAFE VSP[SASP, C, 3083]
        OPTION function = ["aligned_alloc", "calloc", "realloc", "malloc"]
    }
}

//////////////////////////////////////////////////////////////////////////////
// BSSC.101 The programmer must ensure that a pointer to dynamic memory is not
// lost when using realloc().

RULE "51003864" {
    UNSAFE VSP[SASP, C, 3864]
}

//////////////////////////////////////////////////////////////////////////////
// BSSC.112 Macros should not be used with expressions containing side
// effects.

RULE "51003866" {
    UNSAFE VSP[ECP, "macro_sideeffect"]
    OPTION mode = "fast"
    OPTION target = "always"
}

//////////////////////////////////////////////////////////////////////////////
// BSSC.119 The programmer may not assume knowledge of how different data
// types are aligned in memory.

RULE "51003867" {
    UNSAFE VSP[ECP, "bitfield_align"]
}

//////////////////////////////////////////////////////////////////////////////
// BSSC.63 A parameter, which is not changed by the function, should be
// declared 'const'.

RULE "51003869" {
    UNSAFE VSP[ECP, "const_param"]
    OPTION mode = "fast"
    OPTION dest = "general"
    OPTION exclude = ["argc"]
}

//////////////////////////////////////////////////////////////////////////////
// BSSC.92 Conditional expressions must always compare against an explicit
// value.

RULE "51003870" {
    UNSAFE VSP[ECP, "explicit_test_for_func"]
    OPTION zerotest = "false"
}

//////////////////////////////////////////////////////////////////////////////
// BSSC.26 Source code shall be separated into a public interface

// RULE "?" {
//     UNSAFE VSP[ECP, "header_implementation"]
// }

//////////////////////////////////////////////////////////////////////////////
// BSSC.27 The interface file must be included in its own corresponding
// implementation file.

RULE "51003872" {
    UNSAFE VSP[ECP, "include_header"]
}

//////////////////////////////////////////////////////////////////////////////
// BSSC.10 Make sure that any code which you use for debugging purposes does
// not have side effects

RULE "51003873" {
    UNSAFE VSP[ECP, "debug_sideeffect"]
}

//////////////////////////////////////////////////////////////////////////////
// BSSC.107 Diagnostic code should be added to all areas of code which 'should
// never be executed'.

RULE "51003874" {
    UNSAFE VSP[ECP, "empty_default"]
}


RULE "51003524" {
    UNSAFE VSP[ECP, "access_to_uninit_simple"]
}

//////////////////////////////////////////////////////////////////////////////
// HIS.35 Assignment operators shall not be used in expressions which return
// Boolean values.

RULE "51003505" = "51003315"

//////////////////////////////////////////////////////////////////////////////
// HIS.37 Bitwise operators shall not be applied to operands whose underlying
// type is signed.

RULE "51003507" {
    UNSAFE VSP[ECP, "bitop_signed"]
}

//////////////////////////////////////////////////////////////////////////////
// HIS.39 The unary minus operator shall not be applied to an expression whose
// underlying type is unsigned.

RULE "51003508" {
    UNSAFE VSP[ECP, "uminus_unsigned"]
}

//////////////////////////////////////////////////////////////////////////////
// HIS.43 Implicit conversions which may result in a loss of information shall
// not be used

RULE "51003509" {
    UNSAFE VSP[ECP, "implicit_typ_conversion"]
}

//////////////////////////////////////////////////////////////////////////////
// HIS.45 Type casting from any type to or from pointers shall not be used

RULE "51003510" {
    UNSAFE VSP[ECP, "type_casting"]
}

//////////////////////////////////////////////////////////////////////////////
// HIS.48 Mixed precision arithmetic should use explicit casting to generate
// the desired result

RULE "51003511" {
    UNSAFE VSP[ECP, "casting_of_cmplx_expr"]
}

//////////////////////////////////////////////////////////////////////////////
// HIS.72 For each function parameter the type given in the declaration and
// definition shall be identical, and the return types shall also be
// identical.

RULE "51003514" {
    UNSAFE VSP[ECP, "func_proto_dec_check"]
}

//////////////////////////////////////////////////////////////////////////////
// HIS.77 The unqualified type of parameters passed to a function shall be
// compatible with the unqualified expected types defined in the funcion
// prototype

RULE "51003515" {
    UNSAFE VSP[ECP, "implicit_typ_conversion"]
    OPTION param = "true"
}

//////////////////////////////////////////////////////////////////////////////
// HIS.78 The number of parameters passed to a function shall match the
// function prototype

RULE "51003516" {
    UNSAFE VSP[ECP, "func_arity_check"]
}

//////////////////////////////////////////////////////////////////////////////
// HIS.83 For functions with non-void return type, i, there shall be one
// return statement for every exit branch (including the end of program); ii,
// each return shall have an expression; iii, the return expression shall
// match the declared return type

RULE "51003517" {
    UNSAFE VSP[ECP, "nonvoid_return_type"]
    OPTION type = "true"
}

//////////////////////////////////////////////////////////////////////////////
// HIS.84 For functions with void return type, return statements shall not
// have an expression.

RULE "51003518" {
    UNSAFE VSP[ECP, "void_fun_ret_some"]
}

//////////////////////////////////////////////////////////////////////////////
// HIS.101  Pointer arithmetic should not be used

RULE "51003519" {
    UNSAFE VSP[ECP, "pointer_arith"]
}

//////////////////////////////////////////////////////////////////////////////
// HIS.105 All the functions pointed to by a single pointer to function shall
// be identical in the number and type of parameters and the return type

RULE "51003521" {
    UNSAFE VSP[ECP, "func_arity_check_type"]
}

//////////////////////////////////////////////////////////////////////////////
// HIS.112 Bit fileds of type signed int shall be at least 2 bits long

RULE "51003522" {
    UNSAFE VSP[ECP, "bit_fileds"] // FIXME: typo?
}

//////////////////////////////////////////////////////////////////////////////
// HIS.46 Implicit conversions which may result in a loss of information shall
// not be used

RULE "51003528" {
    UNSAFE VSP[ECP, "subexpression_sideeffect"]
}

//////////////////////////////////////////////////////////////////////////////
// HIS.50 Floating point variables shall not be tested for exact equality or
// inequality

RULE "51003529" {
    UNSAFE [($<FLOAT>, [_=, <=, >=], $<FLOAT>)] //@pragma(allow_vague)
}

//////////////////////////////////////////////////////////////////////////////
// HIS.53 All non-null statements shall have a side-effect.

RULE "51003532" = "51003338"

//////////////////////////////////////////////////////////////////////////////
// HIS.67 Numeric variables being used within a for loop for iteration
// counting should not be modified in the body of the loop.

RULE "51003533" = "51003335"

//////////////////////////////////////////////////////////////////////////////
// HIS.70 Functions shall not call themselves, either directly or indirectly

RULE "51003534" {
    UNSAFE VSP[ECP, "rec"]
    OPTION type = "ALL"
}

//////////////////////////////////////////////////////////////////////////////
// HIS.79 The values returned by void functions shall not be used.

RULE "51003535" {
    UNSAFE VSP[ECP, "use_of_void_func"]
}

//////////////////////////////////////////////////////////////////////////////
// HIS.80 Void expressions shall not be passed as function parameters.

RULE "51003536" {
    UNSAFE VSP[ECP, "void_as_param"]
}

//////////////////////////////////////////////////////////////////////////////
// HIS.81 const qualification should be used on function parameters which are
// passed by reference, where it is intended that the function will not modify
// the parameter.

RULE "51003537" {
    UNSAFE VSP[ECP, "const_param"]
    OPTION mode = "fast"
    OPTION dest = "pointer"
}

//////////////////////////////////////////////////////////////////////////////
// HIS.86 If a function returns error information, then that error information
// shall be tested

RULE "51003538" = "51003811"

//////////////////////////////////////////////////////////////////////////////
// HIS.108 In the specification of a structure or union type, all members of
// the structure or union

RULE "51003543" {
    UNSAFE VSP[ECP, "spec_of_struct_union"]
}

//////////////////////////////////////////////////////////////////////////////
// HIS.113 If objects or functions are declared more than once they shall have
// compatible declarations

RULE "51003545" {
    UNSAFE VSP[ECP, "access_structure_by_pointer"]
    OPTION access = "false"
    OPTION bitfield = "true"
    OPTION arith = "true"
}

//////////////////////////////////////////////////////////////////////////////
// JPL.19 The evaluation of a Boolean expression shall have no side effects.

RULE "51003802" {
    UNSAFE VSP[ECP, "condition_sideeffect"]
}

//////////////////////////////////////////////////////////////////////////////
// JPL.29 Non-constant pointers to functions should not be used.

RULE "51003803" {
    UNSAFE VSP[ECP, "declare_non_const_funcptr"]
}

//////////////////////////////////////////////////////////////////////////////
// JPL.30 Conversions shall not be performed between a pointer to a function
// and any type other than an integral type.

RULE "51003804" {
    UNSAFE VSP[ECP, "func_pointer"]
}

//////////////////////////////////////////////////////////////////////////////
// JPL.7 Task synchronization shall not be performed through the use of task
// delays.

RULE "51003807" {
    UNSAFE VSP[ECP, "delay"]
}

//////////////////////////////////////////////////////////////////////////////
// JPL.14 The return value of non-void functions shall be checked or used by
// each calling function, or explicitly cast to (void) if irrelevant.

RULE "51003811" {
    UNSAFE VSP[ECP, "check_returns"]
    OPTION exclude = ["printf", "strcpy"]
}

//////////////////////////////////////////////////////////////////////////////
// JPL.26 Use no more than two levels of indirection per declaration.

RULE "51003814" {
    UNSAFE VSP[ECP, "tripler_pointer"]
}

RULE "51003999" {
    UNSAFE VSP[ECP, "unit"]
}

// MISRA-C-2004 8-9 - No rule
// ARGUMENT none {true, false} DEFAULT false
// ARGUMENT more {true, false} DEFAULT false
// ANALYZER ecp_external_linkages(more:true)

// MISRA-C-20014 16-10 - No rule
// ANALYZER ecp_check_returns(exclude: ["printf"; "strcpy"])

// MISRA-C-20014 18-1 - No rule
// ANALYZER ecp_spec_of_struct_union

// MISRA-C-20014 50 - No rule
// ANALYZER ecp_float_equality(mode:"general+")

// CERT-C-2 EXP35-C - No rule
// ANALYZER ecp_modify_temp_life

// CERT-C-2 INT30-C - No rule
// ARGUMENT intra {true, false} DEFAULT false
// ARGUMENT draw {true, false} DEFAULT false
// ANALYZER ecp_taint_analysis(rule:["INT-30"])

// CERT-C-2 CON01-C - No rule
// ANALYZER ecp_lock_unlock_other_level

// 51003049 = CERT-C-2.API00-C
// 51003050 = CERT-C-2.API07-C
// 51003001 = CERT-C-2.API09-C
// 51003006 = CERT-C-2.DCL12-C
// 51003012 = CERT-C-2.EXP18-C
// 51003015 = CERT-C-2.EXP37-C
// 51003016 = CERT-C-2.EXP38-C
// 51003039 = CERT-C-2.MSC16-C
// 51003053 = CERT-C-2.ARR33-C
// 51003054 = CERT-C-2.ARR34-C
// 51003056 = CERT-C-2.ARR37-C
// 51003057 = CERT-C-2.ARR38-C
// 51003058 = CERT-C-2.CON00-C
// 51003059 = CERT-C-2.CON01-C
// 51003061 = CERT-C-2.CON31-C
// 51003062 = CERT-C-2.CON32-C
// 51003064 = CERT-C-2.CON34-C
// 51003066 = CERT-C-2.CON40-C
// 51003073 = CERT-C-2.ENV03-C
// 51003074 = CERT-C-2.ENV04-C
// 51003075 = CERT-C-2.ENV30-C
// 51003079 = CERT-C-2.ERR03-C
// 51003082 = CERT-C-2.ERR32-C
// 51003094 = CERT-C-2.EXP35-C
// 51003103 = CERT-C-2.FIO17-C
// 51003118 = CERT-C-2.FLP32-C
// 51003121 = CERT-C-2.INT08-C
// 51003125 = CERT-C-2.INT30-C
// 51003126 = CERT-C-2.INT31-C
// 51003127 = CERT-C-2.INT32-C
// 51003135 = CERT-C-2.MEM11-C
// 51003140 = CERT-C-2.MEM35-C
// 51003147 = CERT-C-2.MSC15-C
// 51003149 = CERT-C-2.MSC22-C
// 51003153 = CERT-C-2.MSC39-C
// 51003156 = CERT-C-2.POS30-C
// 51003159 = CERT-C-2.POS37-C
// 51003160 = CERT-C-2.POS38-C
// 51003176 = CERT-C-2.FIO04-C
// 51003179 = CERT-C-2.MSC03-C
// 51003180 = CERT-C-2.POS48-C
// 51003181 = CERT-C-2.POS49-C
// 51003182 = CERT-C-2.POS50-C
// 51003183 = CERT-C-2.POS51-C
// 51003184 = CERT-C-2.POS52-C
// 51003301 = MISRA-C-2004.10.1
// 51003302 = MISRA-C-2004.10.2
// 51003303 = MISRA-C-2004.10.3
// 51003304 = MISRA-C-2004.10.4
// 51003305 = MISRA-C-2004.10.5
// 51003306 = MISRA-C-2004.11.1
// 51003307 = MISRA-C-2004.11.2
// 51003308 = MISRA-C-2004.11.3
// 51003309 = MISRA-C-2004.11.4
// 51003311 = MISRA-C-2004.12.12
// 51003312 = MISRA-C-2004.12.6
// 51003316 = MISRA-C-2004.13-2
// 51003319 = MISRA-C-2004.15-4
// 51003320 = MISRA-C-2004.16-6
// 51003321 = MISRA-C-2004.16-8
// 51003322 = MISRA-C-2004.16-9
// 51003323 = MISRA-C-2004.17-1
// 51003326 = MISRA-C-2004.6-4
// 51003327 = MISRA-C-2004.6-5
// 51003330 = MISRA-C-2004.12-11
// 51003336 = MISRA-C-2004.13.7
// 51003337 = MISRA-C-2004.14.1
// 51003339 = MISRA-C-2004.16.1
// 51003340 = MISRA-C-2004.16-2
// 51003344 = MISRA-C-2004.17.4
// 51003345 = MISRA-C-2004.17.5
// 51003347 = MISRA-C-2004.18.1
// 51003349 = MISRA-C-2004.18.3
// 51003350 = MISRA-C-2004.20.3
// 51003351 = MISRA-C-2004.9.1
// 51003523 = HIS.20
// 51003856 = BSSC.53
// 51003868 = BSSC.123
// 51003875 = BSSC.117
// 51003506 = HIS.36
// 51003512 = HIS.63
// 51003513 = HIS.65
// 51003520 = HIS.104
// 51003525 = HIS.33
// 51003527 = HIS.40
// 51003530 = HIS.51
// 51003539 = HIS.102
// 51003540 = HIS.103
// 51003541 = HIS.106
// 51003542 = HIS.107
// 51003544 = HIS.109
// 51003801 = JPL.17
// 51003805 = JPL.3
// 51003806 = JPL.6
// 51003808 = JPL.8
// 51003809 = JPL.9
// 51003810 = JPL.10
// 51003812 = JPL.15
// 51003813 = JPL.18



// TEST-CONFIG: product=beSOURCE

// Local variables:
// compile-command: "make all rdl && rdl --lint 5111.rdl"
// End:
