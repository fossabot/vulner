SPEC 2

(***
 ***  DO NOT EDIT THIS FILE.
 ***  `rdlpp.ml' AUTOMATICALLY GENERATES THIS FILE FROM `5123.rdl.in'.
 ***  IF YOU WANT TO MAKE A CHANGE, YOU NEED TO EDIT `5123.rdl.in', NOT THIS FILE.
 ***)

(*
   RDL for C++ programs (New Version)
*)

GROUP #External($1) {
    TEMPLATE #placeholder(...):$1,

    /\(\(w\|_w\)?getenv\|getc\)/(...):$1,
    RegQueryValueEx(...,$1,$$),
    cin(..., $1, ...),
    [fgets,fread,fgetws]($1,...),
    fscanf($<NAME stdin>, $$, ..., $1, ...),
    read($$, $1,...),
    scanf($$, ..., $1, ...),
    $1<EXTERN>
}

GROUP #StrMoveFunc($1, $2) {
    TEMPLATE #placeholder($1, ..., $2, ...),

    /_?snw?printf/($1, $$, $$, ..., $2, ...),
    [sprintf,wsprintf]($1, $$, ..., $2, ...),
    [strcat,strcpy,wcscpy]($1, $2),
    [strncat,wcsncat,strncpy]($1, $2, $$),
    sscanf($2, $$, ..., $1, ...)
}

GROUP #ReadFromStdin() {
    TEMPLATE #placeholder(...),

    cin(...),
    [fgets,fread,fgetws](..., $<NAME stdin>),
    fscanf($<NAME stdin>, ...),
    [scanf,gets](...)
}

GROUP #StrCmpFunc($1) {
    TEMPLATE #placeholder(..., $1, ...),

    [strcmp,strstr,strncmp]($$, $1, ...),
    [strcmp,strstr,strncmp]($1, $$, ...)
}

GROUP #StrCmp($1, $2) {
    TEMPLATE #placeholder($1, ..., $2, ...),

    [strcmp,strstr,strncmp]($1, $2, ...)
}

GROUP #StrExam($1) {
    TEMPLATE #placeholder(..., $1, ...),

    [strchr,strcspn,strpbrk,strrchr,strspn,strstr]($1,...)
}

GROUP #LDAPfunction($1, $2) {
    TEMPLATE #placeholder($1, ..., $2, ...),

    // $1 = the DN of the entry at which to start the search.
    // $2 = a string representation of the filter to apply in the search.
    /ldap_search\(_ext\|_ext_s\|_ext_sA\|_ext_sW\|_s\|_st\)?/($$, $1, $$, $2, ...)
}

GROUP #StrDangerousReadFunc($1) {
    TEMPLATE #placeholder(..., $1, ...),

    [strcat,strcpy,strcmp]($$, $1),
    [strcmp,strlen]($1, ...)
}

GROUP #LDFunc($1) {
    TEMPLATE #placeholder(..., $1, ...),

    dlsym($$,$1),
    /\(LoadLibrary[AW]?\|dlopen\)/($1, ...)
}

GROUP #UnsignedAllocFunc($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(calloc\|malloc\|newArray\)/($1, ...),
    realloc($$,$1)
}

GROUP #DBCon($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(OCILogon2?\|SQLConnect\)/($$, $$, $$, $$, $$, $1, ...),
    mysql_real_connect($$, $$, $$, $1, ...),
    createConnection($$, $1, ...)
}

GROUP #FileRead($1) {
    TEMPLATE #placeholder(..., $1, ...),

    [fgets,fread]($1, ...),
    read($$, $1, ...)
}

GROUP #SetID() {
    TEMPLATE #placeholder(),

    /set\(e\|fs\|re\|res\)?[gu]id/(...)
}

GROUP #WeakTempFunc() {
    TEMPLATE #placeholder(),

    {{GetTempFileName
\|_mktemp
\|_tempnam
\|_tmpfile
\|_tmpname
\|mktemp
\|tempnam
\|tmpfile
\|tmpnam
\|tmpnam_r}}(...)
}

GROUP #Alloc() {
    TEMPLATE #placeholder(),

    /\(calloc\|malloc\|realloc\)/(...)
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GROUP #CONNECT($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(connect\|listen\)/($1, ...)
}

GROUP #RECV($1, $2) {
    TEMPLATE #placeholder($1, ..., $2, ...),

    /recv\(_rv\)?/($1, $2, ...)
}

GROUP #UseFile($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(CreateFile[AW]\|\(f\|fre\|_\|_wf\|w\|_w\)?open\|rename\|mkdir\|link\|lstat\|mknod\|symlink\|utime\|chown\|stat\|chmod\)/($1, ...),
    /\(remove\|unlink\|opendir\|rmdir\|unlink\)/($1),
    /\(rename\|link\|symlink\)/(..., $1)
}

GROUP #Res($1) {
    TEMPLATE #placeholder(..., $1, ...),

    connect($$, $1, ...),
    getenv($1, ...)
}

GROUP #Setting($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(sethostid\|SetComputerNameA\)/($1)
}


GROUP #PthreadMutexLock($1) {
    TEMPLATE #placeholder(..., $1, ...),

    [pthread_mutex_lock,pthread_mutex_trylock]($1)
}

GROUP #PthreadMutexUnlock($1) {
    TEMPLATE #placeholder(..., $1, ...),

    pthread_mutex_unlock($1)
}

// #include 5111.rdl GROUP StdThreadsMutexLock
// #include 5111.rdl GROUP StdThreadsMutexUnlock
GROUP #MutexLock($1) {
    TEMPLATE #placeholder(..., $1, ...),

    [pthread_mutex_lock,pthread_mutex_trylock,mtx_lock]($1)
}

GROUP #MutexUnlock($1) {
    TEMPLATE #placeholder(..., $1, ...),

    [pthread_mutex_unlock,mtx_unlock]($1)
}


// CWE-15 External Control of System or Configuration Setting
// [SP] 시스템 또는 구성 설정의 외부 제어
GROUP #"51230015".source = #External
GROUP #"51230015".sink = #Setting
RULE "51230015" {
    PATTERN {
        UNSAFE [#_.source($1)] <--if [#_.sink($1)]
    }

    PATTERN {
        UNSAFE [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
         <--if [#RECV($1, $2)] <--if [#_.sink($2)]
    }
}


// CWE-22 Path Traversal
// [SP] 디렉토리 경로 조작
GROUP #"51230022".source = #External
GROUP #"51230022".sink($1) {
    TEMPLATE #placeholder(..., $1, ...),

    #UseFile, #Res
}

RULE "51230022" {
    PATTERN {
        UNSAFE [#_.source($1)] <--if [#_.sink($1)]
    }

    PATTERN {
        UNSAFE [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
         <--if [#RECV($1, $2)] <--if [#_.sink($2)]
    }

    PATTERN {
        UNSAFE [#_.source($1)] <--if [ASSIGN($2<NAME sin_port> := $1)]
         <--if [#_.sink($2)]
    }
}


// DEPRECATED
// CWE-23 Relative Path Traversal
// [SP] 상대 디렉토리 경로 조작
// #include 5111.rdl RULE 51000023 51230023

// DEPRECATED
// CWE-36 Absolute Path Traversal
// [SP] 절대 디렉토리 경로 조작
// #include 5111.rdl RULE 51000036 51230036

// CWE-41 Improper Resolution of Path Equivalence
// [SP] 경로명 일치 검사에 대한 부적절한 적용
GROUP #Canonicalize($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(realpath\|canonicalize_file_name\)/($1,...)
}

GROUP #"51230041".source = #External
GROUP #"51230041".compare = #StrCmpFunc
GROUP #"51230041".use = #UseFile
GROUP #"51230041".canon = #Canonicalize
RULE "51230041" {
    UNSAFE  AND[[#_.source($1)] <--if [#_.compare($1)];
                [#_.compare($1)] -->if [#_.use($1)]]
    EXCLUDE [#_.canon($$)] <==if [#_.compare($0)]
}


GROUP #C_EXE($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(\(_w\)?system\|_?w?popen\)/($1, ...),
    /_?w?exec[lv]p?/(..., $1, ...),
    /_w?spawnvp?/($$, $1, ...),
    /\(_w?spawnlp?\|_spawnvl\)/($$, ..., $1, ...),
    /_w?spawnvp?/($$, $$, $1, ...)
}


// CWE-78 Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')
// [SP] 운영체제 명령어 삽입
GROUP #"51230078".source = #External
GROUP #"51230078".sink = #C_EXE
RULE "51230078" {
    PATTERN {
        UNSAFE  [#_.source($1)] <--if [#_.sink($1)]
        EXCLUDE [#_.source($1)] <==if [#StrExam($1)] <==if [#_.sink($1)]
    }

    PATTERN {
        UNSAFE [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
         <--if [#RECV($1, $2)] <--if [#_.sink($2)]
    }
}



// CWE-80 Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS)
// [SP] 서버전송 사이트 교차접속 스크립트 공격 취약성
GROUP #CGI_Input($1) {
    TEMPLATE #placeholder(...),

    /cgiFormString\(NoNewLines\|Multiple\)?/($$, $1, ...)
}

GROUP #CGI_Output($1) {
    TEMPLATE #placeholder(..., $1, ...),

    fprintf($<NAME cgiOut>, $$, $1),
    /* /\(printf\|putchar\|fputs\)/($1, ...), */
    /* printf($$, $1), */
    cgiHeaderCookieSetString($1, ...),
    cgiHeaderCookieSetString($$, $1, ...)
}


GROUP #"51230080".source($1) {
    TEMPLATE #placeholder(..., $1, ...),

    #CGI_Input, #External
}

GROUP #"51230080".sink = #CGI_Output
RULE "51230080" {
    PATTERN {
        UNSAFE [#_.source($1)] <--if [#_.sink($1)]
    }

    PATTERN {
        UNSAFE [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
          <--if [#RECV($1, $2)] <--if [#_.sink($2)]
    }
}



// CWE-89 Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')
// [SP] SQL 삽입
GROUP #SQLFunc($1) {
    TEMPLATE #placeholder(..., $1, ...),

    ExecuteSQL($1),
    /\(mysql_query\|PQexec\|SQLExecDirect\|sqlite3_exec\)/($$, $1, ...)
}

GROUP #"51230089".source = #External
GROUP #"51230089".sink = #SQLFunc
RULE "51230089" {
    PATTERN {
        UNSAFE [#_.source($1)] <--if [#_.sink($1)]
    }

    PATTERN {
        UNSAFE [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
         <--if [#RECV($1, $2)] <--if [#_.sink($2)]
    }

    PATTERN {
        UNSAFE [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
         <--if [#RECV($1, $2)] <--if [OCIStmtPrepare($3, $$, $2, ...)]
         <--if [OCIStmtExecute($$, $3, ...)]
    }
}



// CWE-90 Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')
// [SP] LDAP 삽입
GROUP #"51230090".source = #External
GROUP #"51230090".sink = #LDAPfunction
RULE "51230090" {
    PATTERN {
        UNSAFE [#_.source($1)] <--if [#_.sink($$, $1)]
    }

    PATTERN {
        UNSAFE [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
          <--if [#RECV($1, $2)] <--if [#_.sink($$,  $2)]
    }
}


// DEPRECATED
// CWE-99 Improper Control of Resource Identifiers ('Resource Injection')
// [SP] 자원 삽입
// #include 5111.rdl RULE 51000099 51230099


// CWE-113 Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')
// [SP] HTTP 응답 분할
GROUP #CGI_HeaderLocation($1) {
    TEMPLATE #placeholder(..., $1, ...),

    cgiHeaderLocation($1)
}

GROUP #"51230113".source = #CGI_Input
GROUP #"51230113".sink = #CGI_HeaderLocation
RULE "51230113" {
    UNSAFE [#_.source($1)] <--if [#_.sink($1)]
}



// CWE-114 Process Control
// [SP] 프로세스 제어
GROUP #"51230114".source = #External
GROUP #"51230114".sink = #LDFunc
RULE "51230114" {
    PATTERN {
        UNSAFE [#_.source($1)] <--if [#_.sink($1)]
    }

    PATTERN {
        UNSAFE [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
          <--if [#RECV($1, $2)] <--if [#_.sink($2)]
    }

    PATTERN {
        UNSAFE  [$1<STRING>] //@pragma(allow_vague)
          <--rf [#StrMoveFunc($2, $1)] <--rf [#_.sink($2)]
        EXCLUDE [#StrMoveFunc($1, $<LIT {\(/\|[A-Za-z]:\).*}>)] <--rf [#_.sink($1)]
    }
}



// CWE-117 Improper Output Neutralization for Logs
// [SP] 로그에 악성 문자열 미검사
GROUP #SysLog($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(NSLog\|syslog\)/($$,$$,...,$1,...)
}

GROUP #"51230117".source = #External
GROUP #"51230117".sink = #SysLog
RULE "51230117" {
    PATTERN {
        UNSAFE [#_.source($1)] <--if [#_.sink($1)]
    }

    PATTERN {
        UNSAFE [$2<EXTERN>] <--if [#StrMoveFunc($1,$2)] <--rf [#_.sink($1)]
    }
}



// RULEID "51230119"
// UNSAFE VSP[C,119]

// RULEID "51230120"
// UNSAFE VSP[C,120]

// RULEID "51230121"
// UNSAFE VSP[C,121]

// RULEID "51230122"
// UNSAFE VSP[C,122]

// RULEID "51230124"
// UNSAFE VSP[C,124]

// RULEID "51230125"
// UNSAFE VSP[C,125]

// RULEID "51230129"
// UNSAFE VSP[C,129]


GROUP #FormatFunc($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\([wv]?printf\|vwprintf\|v?scanf\)/($1,...),
    /\(\(f\|s\|vf\|vfw\|vs\|fw\)printf\|\(f\|s\|vf\|vs\)scanf\|syslog\(_r\)?\)/($$,$1,...),
    /\(\(cb\|sn\|_sn\|snw\|_snw\|vcb\|vsn\|sw\|vsw\)printf\|v?snscanf\|printf_xy\)/($$,$$,$1,...),
    /v?cbscanf/($$,$$,$$,$1,...)
}

GROUP #"51230134".source = #External
GROUP #"51230134".sink = #FormatFunc
RULE "51230134" {
    PATTERN {
        UNSAFE [#_.source($1)] <--if [#_.sink($1)]
    }

    PATTERN {
        UNSAFE [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
          <--if [#RECV($1, $2)] <--if [#_.sink($2)]
    }
}



GROUP #ReadFunc($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /read\(link\)?/($$,$1,...)
}

GROUP #"51230170".source = #ReadFunc
GROUP #"51230170".sink = #StrDangerousReadFunc
RULE "51230170" {
    UNSAFE [#_.source($1)] <--if [#_.sink($1)]
}



// CWE-190 Integer Overflow or Wraparound
// [SP] 정수 오버플로우
IF !(product == "beSOURCE") THEN
GROUP #"51230190".source = #External
GROUP #"51230190".sanitizer($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51230190" {
    PATTERN {
        UNSAFE  [#_.source($1)] <--if [$1] in ARRAYINDEX
        EXCLUDE [#_.source($1)] <--if [$1] in IFCOND <--if [$1] in ARRAYINDEX
        EXCLUDE [#_.source($1)] <--if [$1] in LOOPCOND <--if [$1] in ARRAYINDEX
        EXCLUDE [#_.source($1)] <--if [#_.sanitizer($1)] <--if [$0] in ARRAYINDEX
    }

    PATTERN {
        UNSAFE  [#UnsignedAllocFunc($<SIGNED>)]
        EXCLUDE [#UnsignedAllocFunc($<CONSTANT>)]
        EXCLUDE [$1<INT OR CHAR>] in IFCOND
          <--rf [#UnsignedAllocFunc($1<SIGNED, NOT CONSTANT>)]
        EXCLUDE [$1<INT OR CHAR>] in LOOPCOND
          <--rf [#UnsignedAllocFunc($1<SIGNED, NOT CONSTANT>)]
        EXCLUDE AND[[fgets($1, $<CONSTANT>, $$)]
                     <--if [#UnsignedAllocFunc($1<SIGNED>)];
                    [$1<SIGNED, CONSTANT>] //@pragma(allow_vague)
          <--if [#UnsignedAllocFunc($1<SIGNED, NOT CONSTANT>)]]
        EXCLUDE [#_.sanitizer($$)]
          <--if [#UnsignedAllocFunc($0<SIGNED, NOT CONSTANT>)]
    }

    PATTERN {
        UNSAFE  [#_.source($1)]
          <--if [($1<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [($<INT OR CHAR, BOUNDED[-10000, 10000]>, +, $<INT OR CHAR, BOUNDED[-10000, 10000]>)]
        EXCLUDE [($1, _<, $$)] //@pragma(allow_vague)
          <--rf [($1<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [#_.source($1)]
          <--if [#_.sanitizer($1)]
          <--if [($1<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
    }

    PATTERN {
        UNSAFE  [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
          <--if [#RECV($1, $2)]
          <--if [($2<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [($<INT OR CHAR, BOUNDED[-10000, 10000]>, +, $<INT OR CHAR, BOUNDED[-10000, 10000]>)]
        EXCLUDE [($1, _<, $$)] //@pragma(allow_vague)
          <--if [($1<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
    }

    PATTERN {
        UNSAFE  [#_.source($1)]
          <--if [($1<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [($<INT OR CHAR, BOUNDED[-100, 100]>, *, $<INT OR CHAR, BOUNDED[-100, 100]>)]
        EXCLUDE [($1, _<, $$)] //@pragma(allow_vague)
          <--if [($1<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [#_.source($1)]
          <--if [#_.sanitizer($1)]
          <--if [($1<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
    }

    PATTERN {
        UNSAFE  [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
          <--if [#RECV($1, $2)]
          <--if [($2<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [($<INT OR CHAR, BOUNDED[-100, 100]>, *, $<INT OR CHAR, BOUNDED[-100, 100]>)]
        EXCLUDE [($1, _<, $$)] //@pragma(allow_vague)
          <--if [($1<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
    }

    PATTERN {
        UNSAFE  [$1<NAME /\(SHRT\|U?CHAR\|U?INT\|LLONG\)_MAX/>]
          <--rf [($1<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [($<INT OR CHAR, BOUNDED[-10000, 10000]>, +, $<INT OR CHAR, BOUNDED[-10000, 10000]>)]
        EXCLUDE [($1, _<, $$)] //@pragma(allow_vague)
          <--rf [($1<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
    }

    PATTERN {
        UNSAFE  [$1<NAME /\(SHRT\|U?CHAR\|U?INT\|LLONG\)_MAX/>]
          <--rf [($1<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [($<INT OR CHAR, BOUNDED[-100, 100]>, *, $<INT OR CHAR, BOUNDED[-100, 100]>)]
        EXCLUDE [($1, _<, $$)] //@pragma(allow_vague)
          <--if [($1<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
    }

//  CHAR : 127
// SHORT : 32767
//   INT : 2147483647
// LLONG : 9223372036854775807
// UCHAR : 0xff
//  UINT : 0xffffffff
    PATTERN {
        UNSAFE  [ASSIGN($1 := $<INT OR CHAR, LIT
           /\(127\|32767\|2147483647\|9223372036854775807\|0xff\|0xffffffff\)/>)]
          <--rf [($1<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [($<INT OR CHAR, BOUNDED[-10000, 10000]>, +, $<INT OR CHAR, BOUNDED[-10000, 10000]>)]
        EXCLUDE [($1, _<, $$)] //@pragma(allow_vague)
          <--rf [($1<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
    }

    PATTERN {
        UNSAFE  [ASSIGN($1 := $<INT OR CHAR, LIT
           /\(127\|32767\|2147483647\|9223372036854775807\|0xff\|0xffffffff\)/>)]
          <--rf [($1<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [($1, _<, $$)] //@pragma(allow_vague)
          <--if [($1<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
    }

    PATTERN {
        UNSAFE  [[rand,RAND32,RAND64]()]
          <--if [($0<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [($<INT OR CHAR, BOUNDED[-10000, 10000]>, +, $<INT OR CHAR, BOUNDED[-10000, 10000]>)]
        EXCLUDE [($1, _<, $$)] //@pragma(allow_vague)
          <--rf [($1<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [[rand,RAND32,RAND64]()]
          <--if [#_.sanitizer($0)]
          <--if [($0<INT OR CHAR>, +, $<POSITIVE>)<NOT BOUNDED[-20000, 20000]>]
    }

    PATTERN {
        UNSAFE  [[rand,RAND32,RAND64]()]
          <--if [($0<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [($1, _<, $$)] //@pragma(allow_vague)
          <--if [($1<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
        EXCLUDE [[rand,RAND32,RAND64]()]
          <--if [#_.sanitizer($0)]
          <--if [($0<INT OR CHAR>, *, $$)<NOT BOUNDED[-20000, 20000]>]
    }
}

ENDIF

RULE "51230194" {
    UNSAFE VSP[SASP, C,194]
}



RULE "51230195" {
    UNSAFE VSP[SASP, C,195]
}



RULE "51230196" {
    UNSAFE [ASSIGN ($<SIGNED> := $<UNSIGNED>)]
}



// CWE-209 Information Exposure Through an Error Message
// [SP] 오류 메시지 통한 정보 노출
GROUP #GetInfo() {
    TEMPLATE #placeholder(...),

    getenv(...)
}

GROUP #PrintError($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /fw?printf/($<NAME /_?stderr/>, $$, ..., $1, ...)
}

GROUP #"51230209".source = #GetInfo
GROUP #"51230209".sink = #PrintError
RULE "51230209" {
    UNSAFE [#_.source()] <--rf [#_.sink($0)]
}



GROUP #Danger() {
    TEMPLATE #placeholder(...),

    {{\(gets
\|sprintf
\|strcat
\|strcpy
\|vsprintf
\)}}(...)
}

GROUP #"51230242".blacklist = #Danger
RULE "51230242" {
    UNSAFE [#_.blacklist()]
}



GROUP #Chroot() {
    TEMPLATE #placeholder(...),

    chroot(...)
}

GROUP #Chdir($1) {
    TEMPLATE #placeholder(..., $1, ...),

    chdir($1)
}

GROUP #"51230243".chroot = #Chroot
GROUP #"51230243".chdir = #Chdir
RULE "51230243" {
    UNSAFE  [#_.chroot()]
    EXCLUDE [#_.chroot()] ==>cf [#_.chdir("/"<STRING>)]
}



GROUP #ReleaseWithoutClear() {
    TEMPLATE #placeholder(...),

    realloc(...)
}

GROUP #ClearMemory($1) {
    TEMPLATE #placeholder(..., $1, ...),

    SecureZeroMemory($1, ...)
}

GROUP #C_LOGON($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /LogonUser[AW]/($$, $$, $1, ...),
    /\(OCILogon2?\|SQLConnect\)/($$, $$, $$, $$, $$, $1, ...),
    mysql_real_connect($$, $$, $$, $1, ...)
}

GROUP #"51230244".blacklist = #ReleaseWithoutClear
GROUP #"51230244".alloc = #Alloc
GROUP #"51230244".external = #External
GROUP #"51230244".clear = #ClearMemory
GROUP #"51230244".sensitive = #C_LOGON
RULE "51230244" {
    PATTERN {
        UNSAFE  [#_.blacklist()]
    }

    PATTERN {
        UNSAFE  [#_.alloc()] <--if [#_.sensitive($0)]
        EXCLUDE [#_.sensitive($1)] -->if [#_.clear($1)]
    }

    PATTERN {
        UNSAFE  [#_.external($1)] <--if [#_.sensitive($1)]
        EXCLUDE [#_.sensitive($1)] -->if [#_.clear($1)]
    }
}



// CWE-247: Reliance on DNS Lookups in a Security Decision
// [SP] 보안 결정시 DNS lookup에 의존
GROUP #DNSFunc() {
    TEMPLATE #placeholder(...),

    [gethostbyaddr,gethostbyname,gethostbyname2](...)
}

GROUP #"51230247".dns = #DNSFunc
IF !(product == "beSOURCE") THEN
GROUP #"51230247".check = #StrCmpFunc
ENDIF
RULE "51230247" {
    PATTERN {
        UNSAFE [#_.dns()]
         <--if [ASSIGN($1 := inet_addr($0))]
         <--if [connect($$, $1, $$)]
    }

    // PATTERN {
    //     UNSAFE [#CGI_Input($1)] <--if [#_.check($1)] <--if [$0] in IFCOND
    // }
}


// FIXME: IF...ENDIF in RULE
// beSOURCE: Too slow
IF !(product == "beSOURCE") THEN
ADD-PATTERN "51230247" {
    UNSAFE [#_.dns()] <--if [#_.check($0)] <--if [$0@checked]
}

ADD-PATTERN "51230247" {
    UNSAFE [#_.dns()] <--if [#_.check($0)@checked]
}
ENDIF

GROUP #MBSFunc() {
    TEMPLATE #placeholder(...),

    {{_mbs\(
cpy
\|dec
\|inc
\|len
\|ncat
\|ncpy
\|nextc
\|nset
\|rev
\|set
\|str
\|tok
\)}}(...)
}

GROUP #"51230251".blacklist = #MBSFunc
RULE "51230251" {
    UNSAFE [#_.blacklist()]
}



// CWE-252 Unchecked Return Value
// [SP] 함수 결과 검사 부재
GROUP #"51230252".lock = #PthreadMutexLock
GROUP #"51230252".alloc = #UnsignedAllocFunc
GROUP #"51230252".read = #StrDangerousReadFunc
RULE "51230252" {
    PATTERN {
        UNSAFE  [#_.lock($$)]
        EXCLUDE [#_.lock($$)] ==>rf [$0] in IFCOND
        EXCLUDE [#_.lock($$)] ==>rf [$0] in LOOPCOND
    }

    PATTERN {
        UNSAFE  [#_.alloc($$)]
        EXCLUDE [#_.alloc($$)] ==>rf [$0] in IFCOND
        EXCLUDE [#_.alloc($$)] ==>rf [$0] in LOOPCOND
        EXCLUDE [#_.alloc($$)] ==>rf [realloc($0, ...)]
    }

    PATTERN {
        UNSAFE  [fgets($1,...)] <--rf [#_.read($1)]
        EXCLUDE [fgets($1,...)] <--df [$0] in IFCOND
          <--rf [#_.read($1)]
        EXCLUDE [fgets($1,...)] <--df [$0] in LOOPCOND
          <--rf [#_.read($1)]
    }
}



// CWE-256 Plaintext Storage of a Password
// [SP] 패스워드 평문 저장
GROUP #Decrypt($1) {
    TEMPLATE #placeholder(..., $1, ...),

    CryptDecrypt($$, $$, $$, $$, $1, $$)
}

GROUP #"51230256".source = #External
GROUP #"51230256".sink = #C_LOGON
GROUP #"51230256".decrypt = #Decrypt
GROUP #"51230256".sanitizer($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51230256" {
    UNSAFE  [#_.source($1)] <--if [#_.sink($1)]
    EXCLUDE [#_.decrypt($1)] <--if [#_.sink($1)]
    EXCLUDE [#_.decrypt($1)] <--if [memcpy($2, $1, $$)] <--if [#_.sink($2)]
    EXCLUDE [#_.source($1)] <--if [#_.sanitizer($1)] <--if [#_.sink($0)]
}


// CWE-258 Empty Password in Configuration File
// [SP] 설정파일에 빈 (Empty) 패스워드
GROUP #"51230258".source = #FileRead
GROUP #"51230258".sink = #DBCon
GROUP #"51230258".sanitizer($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51230258" {
    UNSAFE  [#_.source($1)] -->if [#_.sink($1)]
    EXCLUDE [#_.source($1)] -->if [#_.sanitizer($1)] -->if [#_.sink($1)]
}



// CWE-259 Use of Hard-coded Password
// [SP] 하드코드된 패스워드
GROUP #"51230259".password = #C_LOGON
GROUP #"51230259".external = #External
RULE "51230259" {
    PATTERN {
        UNSAFE  [$1<CONSTANT>] //@pragma(allow_vague)
          <--rf [#_.password($1)]
        EXCLUDE [$1<LIT "\0">] <--rf [#_.password($1)]
        EXCLUDE [#_.external($1)] <--rf [#_.password($1)]
    }

    PATTERN {
        UNSAFE  [#StrMoveFunc($1, $<CONSTANT>)] <--if [#_.password($1)]
        EXCLUDE [#_.external($1)] <--rf [#_.password($1)]
    }

    PATTERN {
        UNSAFE  [$1<CONSTANT>] //@pragma(allow_vague)
          <--rf [#StrMoveFunc($2, $1)] <--rf [#_.password($2)]
        EXCLUDE [#_.external($1)] <--rf [#_.password($1)]
    }
}



// CWE-260 Password in Configuration File
// [SP] 설정파일에 패스워드
GROUP #"51230260".source = #FileRead
GROUP #"51230260".sink = #DBCon
GROUP #"51230260".sanitizer($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51230260" {
    UNSAFE  [#_.source($1)] -->if [#_.sink($1)]
    EXCLUDE [#_.source($1)] -->if [#_.sanitizer($1)] -->if [#_.sink($1)]
}



// CWE-261 Weak Cryptography for Passwords
// [SP] 패스워드에 사용된 취약한 암호화
GROUP #CBase64() {
    TEMPLATE #placeholder(...),

    /\([bB]ase64\(_?Decode\)?\|unbase64\)/(...)
}

GROUP #"51230261".blacklist = #CBase64
GROUP #"51230261".password = #DBCon
RULE "51230261" {
    UNSAFE [#_.blacklist()] -->cf [#_.password($$)]
}



RULE "51230266" {
    UNSAFE [#SetID()]
}



GROUP #PrvlgFn() {
    TEMPLATE #placeholder(...),

    chroot(...)
}

GROUP #CreateProcess($1) {
    TEMPLATE #placeholder(..., $1, ...),

    [CreateProcessA,CreateProcessW]($$, $1, ...),
    [CreateProcessAsUserA,CreateProcessAsUserW]($$, $$, $1, ...)
}

GROUP #RegKey($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /Reg\(Create\|Open\)Key\(Ex\)?[AW]/($1, ...)
}

RULE "51230272" {
    PATTERN {
        UNSAFE  [#PrvlgFn()]
        EXCLUDE [#PrvlgFn()] ==>cf [#SetID()]
    }

    PATTERN {
        UNSAFE  [#CreateProcess($<STRING>)]
        EXCLUDE [#CreateProcess($<LIT {{".*".*}}>)]
    }

    PATTERN {
        UNSAFE [#RegKey($<NAME HKEY_LOCAL_MACHINE>)]
    }

    PATTERN {
        UNSAFE [/SHRegCreateUSKey[AW]/($$, $$, $$, $$, $<NAME SHREGSET_HKLM>)]
    }

    PATTERN {
        UNSAFE [/SHRegOpenUSKey[AW]/($$, $$, $$, $$, "1"<INT>)]
    }
}



// CWE-285 Improper Authorization
// [SP] 부적절한 인가
GROUP #CLDAPAuth($1, $2, $3) {
    TEMPLATE #placeholder($1, ..., $2, ..., $3, ...),

    /ldap_simple_bind\(_s\)?/($1, $2, $3)
}

GROUP #LDAPSearch($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /ldap_search\(_s\)?/($1, ...)
}

GROUP #"51230285".auth = #CLDAPAuth
GROUP #"51230285".search = #LDAPSearch
RULE "51230285" {
    PATTERN {
        UNSAFE  [#_.search($$)]
        EXCLUDE [#_.auth($1, $<NOT NULLABLE>, $<NOT NULLABLE>)]
          <--if [#_.search($1)]
    }

    PATTERN {
        UNSAFE  [CreateDesktopA($$, $$, $$, $$, $<NAME GENERIC_ALL>, $$)]
        EXCLUDE [CreateDesktopA($$, $$, $$, $$, $<NAME GENERIC_ALL>, $$)] in IFBODY
    }
}



GROUP #Auth() {
    TEMPLATE #placeholder(...),

    AuthenticateUser(...)
}

GROUP #"51230307".auth = #Auth
RULE "51230307" {
    PATTERN {
        UNSAFE  [#_.auth()] in LOOPBODY
        EXCLUDE [[$$, <, $<INT>, >]] in LOOPCOND
          <--cf [#_.auth()] in LOOPBODY
        EXCLUDE [#_.auth()] in LOOPBODY
          -->cf [[$$, <, $<INT>, >]] in LOOPCOND
    }

    // FIXME: What's the point?
    // UNSAFE  [#ExtFunc()] <--if [#StrCmpFunc($0)] in IFCOND
    // EXCLUDE [#StrCmpFunc($$)] in IFCOND -->cf [[$$, >_< ,$<INT>, >_<]] in IFCOND
    // UNSAFE  [#ExtFunc2($1)] <--if [#StrCmpFunc($1)] in IFCOND
    // EXCLUDE [#StrCmpFunc($$)] in IFCOND -->cf [[$$, >_< ,$<INT>, >_<]] in IFCOND
}



GROUP #Output($1) {
    TEMPLATE #placeholder(..., $1, ...),

    [printf,wprintf]($$, ..., $1, ...),
    /fw?printf/($$, $$, ..., $1, ...),
    /\(f?puts\|fwrite\)/($1, ...),
    write($$, $1, $$)
}

GROUP #"51230312".source = #External
GROUP #"51230312".decrypt = #Decrypt
GROUP #"51230312".sensitive = #C_LOGON
GROUP #"51230312".stdin = #ReadFromStdin
RULE "51230312" {
    // PATTERN {
    //     UNSAFE [#_.source1()] <--if [#_.output($0)]
    // }

    // PATTERN {
    //     UNSAFE [#_.source2($1)] <--if [#_.output($1)]
    // }

    // PATTERN {
    //     UNSAFE [$1<EXTERN>] <--if [#_.output($1)]
    // }

    // PATTERN {
    //     UNSAFE  [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
    //       <--if [#RECV($1, $2)] <--if [#_.output($2)]
    //     EXCLUDE [memcpy($1, ...)] <--if [#_.output($1)]
    // }

    PATTERN {
        UNSAFE  [recv($$, $1, $$, $$)] <--if [#_.sensitive($1)]
        EXCLUDE [#_.decrypt($1)] <--if [memcpy($2, $1, $$)] <--if [#_.sensitive($2)]
    }

    PATTERN {
        UNSAFE  [#_.source($1)] \ [#_.stdin()]
          <--if [#_.sensitive($1)]
        EXCLUDE [#_.decrypt($2)] <--if [memcpy($3, $2, $$)] <--if [#_.sensitive($3)]
    }
}


// CWE-319 Cleartext Transmission of Sensitive Information
// [SP] 기밀 정보의 단순한 텍스트 전송
GROUP #"51230319".source = #External
GROUP #"51230319".decrypt = #Decrypt
GROUP #"51230319".sensitive = #C_LOGON
RULE "51230319" {
    PATTERN {
        UNSAFE  [#_.source($1)] <--if [#_.sensitive($1)]
        EXCLUDE [#_.decrypt($2)] <--if [memcpy($3, $2, $$)] <--if [#_.sensitive($3)]
    }

    PATTERN {
        UNSAFE  [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
          <--if [#RECV($1, $2)] <--if [#_.sensitive($2)]
        EXCLUDE [memcpy($1, ...)] <--if [#_.sensitive($1)]
        EXCLUDE [#_.decrypt($2)] <--if [memcpy($3, $2, $$)] <--if [#_.sensitive($3)]
    }

    PATTERN {
        UNSAFE  [recv($$, $1, $$, $$)] <--if [#_.sensitive($1)]
        EXCLUDE [#_.decrypt($2)] <--if [memcpy($3, $2, $$)] <--if [#_.sensitive($3)]
    }
}


// CWE-321 Use of Hard-coded Cryptographic Key
// [SP] 하드코드된 암호화키 사용
GROUP #STRcomp($1, $2) {
    TEMPLATE #placeholder($1, ..., $2, ...),

    /strn?cmp/($1, $2, ...)
}

GROUP #EncryptKey($1) {
    TEMPLATE #placeholder(..., $1, ...),

    CryptEncrypt($1, ...)
}

GROUP #"51230321".key = #EncryptKey
RULE "51230321" {
    PATTERN {
        UNSAFE [ASSIGN($1 := crypt(...))] -->rf [#STRcomp($1, $<CONSTANT>)]
         -->if [#DBCon($1)]
    }

    PATTERN {
        UNSAFE [ASSIGN($1 := crypt(...))] -->rf [#STRcomp($<CONSTANT>, $1)]
         -->if [#DBCon($1)]
    }

    PATTERN {
        UNSAFE [$1<CONSTANT>] //@pragma(allow_vague)
         <--if [#_.key($1)]
    }

    PATTERN {
        UNSAFE [#StrMoveFunc($1, $<CONSTANT>)] <--if [#_.key($1)]
    }

    PATTERN {
        UNSAFE [#StrMoveFunc($1, $<CONSTANT>)] <--if [CryptHashData($2, $1, ...)]
         <--if [CryptDeriveKey($$, $$, $2, $$, $3)] <--if [CryptEncrypt($3, ...)]
    }
}



GROUP #HashEnc($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(MD5\|SHA1\)/($1, ...)
}

GROUP #"51230323".nonce = #HashEnc
RULE "51230323" {
    PATTERN {
        UNSAFE [$1<CONSTANT>] //@pragma(allow_vague)
         <--if [#_.nonce($1)]
    }

    PATTERN {
        UNSAFE [#StrMoveFunc($1, $<CONSTANT>)] <--if [#_.nonce($1)]
    }
}


GROUP #InadequateEncrypt() {
    TEMPLATE #placeholder(...),

    RSA_generate_key($<INT, LIT /\(1\|128\|16\|2\|256\|32\|4\|512\|64\|8\)/>, $$, $$, $$),
    opensslcrypt($$, $<BOUNDED[*,127]>, ...)
}

GROUP #"51230326".blacklist = #InadequateEncrypt
RULE "51230326" {
    UNSAFE [#_.blacklist()]
}


// CWE-327 Use of a Broken or Risky Cryptographic Algorithm
// [SP] 취약한 암호화 알고리즘의 사용
GROUP #BadEnc() {
    TEMPLATE #placeholder(),

    /EVP_des_\(cbc\|cfb\|ecb\|ofb\)/(...)
}

GROUP #"51230327".blacklist = #BadEnc
RULE "51230327" {
    PATTERN {
        UNSAFE [#_.blacklist()]
    }

    PATTERN {
        UNSAFE [CryptDeriveKey($$, $<NAME /CALG_\(DES\|3DES\|RC5\)/>, $$, $$, $1)]
         <--if [CryptDecrypt($1, ...)]
    }
}



// CWE-328 Reversible One-Way Hash
// [SP] 역산이 가능한 단방향 해쉬함수
GROUP #C_WeakHashFn() {
    TEMPLATE #placeholder(...),

    /MD[245]_\(Final\|Init\|Update\)/(...)
}

GROUP #"51230328".blacklist = #C_WeakHashFn
RULE "51230328" {
    UNSAFE [#_.blacklist()]
}



// CWE-329: Not Using a Random IV with CBC Mode
// [SP] CBC 모드에서 난수화된 초기화 백터 미사용
GROUP #CEncInit($1) {
    TEMPLATE #placeholder(..., $1, ...),

    EVP_EncryptInit($$, $$, $$, $1)
}

GROUP #"51230329".iv = #CEncInit
RULE "51230329" {
    PATTERN {
        UNSAFE [#_.iv($<CONSTANT>)]
    }

    PATTERN {
        UNSAFE [$1<CONSTANT>] //@pragma(allow_vague)
         -->rf [#_.iv($1)]
    }

    PATTERN {
        UNSAFE [memset($1, $<CONSTANT>, ...)] <--rf [#_.iv($1)]
    }
}



// CWE-330 Use of Insufficiently Random Values
// [SP] 적절하지 않은 난수값의 사용
GROUP #CSetSeed($1) {
    TEMPLATE #placeholder(..., $1, ...),

    [srand,srandom]($1)
}

GROUP #RNG() {
    TEMPLATE #placeholder(...),

    [rand,random](...)
}

GROUP #PredictableSrc() {
    TEMPLATE #placeholder(...),

    /\(getp?pid\|gettimeofday\|time\)/(...)
}

GROUP #"51230330".predictable = #PredictableSrc
GROUP #"51230330".seed = #CSetSeed
GROUP #"51230330".random = #RNG
RULE "51230330" {
    PATTERN {
        UNSAFE [#_.seed($<CONSTANT>)] <--cf [#_.random()]
    }

    PATTERN {
        UNSAFE [#_.predictable()] <--cf [#_.seed($$)]
    }

    PATTERN {
        UNSAFE  [#_.random()]
        EXCLUDE [#_.seed($$)] <--cf [#_.random()]
    }
}



// CWE-359 Privacy Violation
// [SP] 개인정보 침해
GROUP #CPrivacyFn() {
    TEMPLATE #placeholder(...),

    /[Gg]etPassword/(...)
}

GROUP #"51230359".privacy = #CPrivacyFn
GROUP #"51230359".output = #Output
GROUP #"51230359".sanitizer($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51230359" {
    UNSAFE  [#_.privacy()] -->rf [#_.output($0)]
    EXCLUDE [#_.privacy()] -->rf [#_.sanitizer($0)] -->rf [#_.output($0)]
}



RULE "51230364" {
    PATTERN {
        UNSAFE VSP[SASP, C,364]
    }

    PATTERN {
        UNSAFE VSP[SASP, C,3641]
    }

    PATTERN {
        UNSAFE [signal($$,$1)] -->rf [signal($$,$1)]
    }
}



GROUP #C_CHECK($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(access\|f?stat\)/($1, ...)
}

GROUP #C_CHECK_WIN($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /_\(access\|f?stat\)/($1, ...)
}

GROUP #UseFileWin($1) {
    TEMPLATE #placeholder(..., $1, ...),

    _open($1, ...)
}

GROUP #"51230367".check($1) {
    TEMPLATE #placeholder(..., $1, ...),

    #C_CHECK, #C_CHECK_WIN
}

GROUP #"51230367".use($1) {
    TEMPLATE #placeholder(..., $1, ...),

    #UseFile, #UseFileWin
}

RULE "51230367" {
    UNSAFE [#_.check($1)] <--if [#_.use($1)]
}



// CW-369 Divide By Zero
// [SP] 0으로 나누기
RULE "51230369" {
    PATTERN {
        UNSAFE  [($$, /, $$)] //@pragma(allow_vague)
        EXCLUDE [$1] in IFCOND  //@pragma(allow_vague)
          <==rf [($$, /, $1)]  //@pragma(allow_vague)
    }

    PATTERN {
        UNSAFE [($$, /, $<ZERO>)]
    }
}



// CWE-377 Insecure Temporary File
// [SP] 안전하지 않은 임시 파일
GROUP #"51230377".blacklist = #WeakTempFunc
RULE "51230377" {
    UNSAFE [#_.blacklist()]
}



// CWE-385 Covert Timing Channel
// [SP] 은밀한 타이밍 채널
RULE "51230385" {
    PATTERN {
        UNSAFE [return] in IFBODY
    }

    PATTERN {
        UNSAFE [return] in LOOPBODY
    }
}



// CWE-386 Symbolic Name not Mapping to Correct Object
// [SP] 심볼릭명이 정확한 대상에 매핑되어 있지 않음
// 삭제해야함
RULE "51230386" {
    PATTERN {
        UNSAFE [#WeakTempFunc()]
    }

    PATTERN {
        UNSAFE [access($1,...)] <--rf [fopen($1,...)]
    }
}



// CWE-390 Detection of Error Condition Without Action
// [SP] 액션 없는 오류 조건 탐지
GROUP #ErroredFunc() {
    TEMPLATE #placeholder(...),

    [calloc,CreateMutex,CreateNamedPipeA,
     fgets,fgetws,fopen,fprintf,fwprintf,fputc,fputs,fputwc,fputws,
     fread,fscanf,fwscanf,fwrite,GetLastError,malloc,
     putc,puts,putwc,putws,putchar,putwchar,_putws,
     realloc,remove,rename,scanf,wscanf,
     _snprintf,_snwprintf,sscanf,swscanf,_wfopen,wremove,_wremove,
     wrename,_wrename
    ](...)
}

GROUP #ErrCode() {
    TEMPLATE #placeholder(...),

    [sqrt,strtol,wcstombs](...)
}

GROUP #ErrCodeDirect() {
    TEMPLATE #placeholder(...),

    sqrt(...)
}

GROUP #CustomErrored() {
    TEMPLATE #placeholder(...),

    [ImpersonateSelf,RpcImpersonateClient](...)
}

GROUP #"51230390".error() {
    TEMPLATE #placeholder(..., $1, ...),

    #ErroredFunc, #CustomErrored
}

GROUP #"51230390".errno = #ErrCodeDirect
GROUP #"51230390".werrno = #ErrCode
RULE "51230390" {
    PATTERN {
        UNSAFE [#_.error()] in IFCOND in IF<EMPTY>
    }

    PATTERN {
        UNSAFE [#_.error()] <--rf [$0] in IFCOND in IF<EMPTY>
    }

    PATTERN {
        UNSAFE [#_.werrno()] <--cf [_get_errno($1)]
         <--rf [$1] in IFCOND in IF<EMPTY>
    }

    PATTERN {
        UNSAFE [#_.errno()] <--cf [$<NAME errno>] in IFCOND in IF<EMPTY>
    }
}



// CWE-400 Uncontrolled Resource Consumption ('Resource Exhaustion')
// [SP] 제어되지 않는 자원 사용
GROUP #SLEEP($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(s\|S\|us\)leep/($1)
}

GROUP #RES_EX() {
    TEMPLATE #placeholder(...),

    /\(printLine\|fwrite\)/(...)
}

GROUP #"51230400".source($1) {
    TEMPLATE #placeholder(...),

    #External, RAND32():$1
}

GROUP #"51230400".resource1 = #SLEEP
GROUP #"51230400".resource2 = #RES_EX
RULE "51230400" {
    PATTERN {
        UNSAFE  [#_.source($1)] <--if [#_.resource1($1)]
        EXCLUDE AND[[[$1, _<, $$, >_]] in IFCOND <--rf [#_.resource1($1)];
                   [[$1, >_, $$, _<]] in IFCOND <--rf [#_.resource1($1)]]
    }

    PATTERN {
        UNSAFE  [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
          <--if [#RECV($1, $2)] <--if [atoi($2)] <--rf [#_.resource1($0)]
        EXCLUDE AND[[[$1, _<, $$, >_]] in IFCOND <--rf [#_.resource1($1)];
                   [[$1, >_, $$, _<]] in IFCOND <--rf [#_.resource1($1)]]
    }

    PATTERN {
        UNSAFE  [RAND32()] <--rf [$0<INT>] in LOOPCOND
          <--cf [#_.resource2()] in LOOPBODY
        EXCLUDE AND[[[$1, _<, $$, >_]] in IFCOND <--rf [$1] in LOOPCOND
                    <--cf [#_.resource2()] in LOOPBODY;
                    [[$1, >_, $$, _<]] in IFCOND <--rf [$1] in LOOPCOND
                    <--cf [#_.resource2()] in LOOPBODY]
    }

    PATTERN {
        UNSAFE  [#_.source($1)] <--rf [$1<INT>] in LOOPCOND
          <--cf [#_.resource2()] in LOOPBODY
        EXCLUDE AND[[[$1, _<, $$, >_]] in IFCOND <--rf [$1] in LOOPCOND
                    <--cf [#_.resource2()] in LOOPBODY;
                    [[$1, >_, $$, _<]] in IFCOND <--rf [$1] in LOOPCOND
                    <--cf [#_.resource2()] in LOOPBODY]
    }

    PATTERN {
        UNSAFE  [#_.source($1)] <--rf [atoi($1)] <--rf [$0<INT>] in LOOPCOND
          <--cf [#_.resource2()] in LOOPBODY
        EXCLUDE AND[[[$1, _<, $$, >_]] in IFCOND <--rf [$1] in LOOPCOND
                    <--cf [#_.resource2()] in LOOPBODY;
                    [[$1, >_, $$, _<]] in IFCOND <--rf [$1] in LOOPCOND
                    <--cf [#_.resource2()] in LOOPBODY]
    }

    PATTERN {
        UNSAFE  [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
          <--if [#RECV($1, $2)] <--if [atoi($2)] <--rf [$0<INT>] in LOOPCOND
          <--cf [#_.resource2()]
        EXCLUDE AND[[[$1, _<, $$, >_]] in IFCOND <--rf [$1] in LOOPCOND
                    <--cf [#_.resource2()];
                    [[$1, >_, $$, _<]] in IFCOND <--rf [$1] in LOOPCOND
                    <--cf [#_.resource2()]]
    }
}



//RULEID "51230401"
//UNSAFE VSP[C,401]


// CWE-404: Improper Resource Shutdown or Release
// [SP] 자원의 부적절한 반환
GROUP #AllocDBHandle($1) {
    TEMPLATE #placeholder(..., $1, ...),

    SQLAllocHandle($$,$$,$1)
}

GROUP #FreeSocket($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /close\(socket\)?/($1)
}

GROUP #AllocSocket() {
    TEMPLATE #placeholder(...),

    /\(accept\|socket\)/(...)
}

GROUP #AllocMem() {
    TEMPLATE #placeholder(...),

    /[mc]alloc/(...)
}

GROUP #FreeDBHandle($1) {
    TEMPLATE #placeholder(..., $1, ...),

    SQLFreeHandle($$,$1)
}

GROUP #FOpen() {
    TEMPLATE #placeholder(...),

    /f\(re\)?open/(...)
}

GROUP #FClose($1) {
    TEMPLATE #placeholder(..., $1, ...),

    fclose($1)
}

GROUP #FreeHeap($1) {
    TEMPLATE #placeholder(..., $1, ...),

    free($1)
}

GROUP #"51230404".close($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51230404" {
    PATTERN {
        UNSAFE  [#AllocDBHandle($$)]
        EXCLUDE [#AllocDBHandle($1)] -->if [#FreeDBHandle($1)]
        EXCLUDE [#AllocDBHandle($1)] -->if [#_.close($1)]
    }

    PATTERN {
        UNSAFE  [#AllocSocket()]
        EXCLUDE [#AllocSocket()] -->if [#FreeSocket($0)]
        EXCLUDE [#AllocSocket()] -->if [#_.close($0)]
    }

    PATTERN {
        UNSAFE  [#FOpen()]
        EXCLUDE [#FOpen()] -->if [#FClose($0)]
        EXCLUDE [#FOpen()] -->if [#_.close($0)]
    }

    PATTERN {
        UNSAFE  [open(...)]
        EXCLUDE [open(...)] -->if [close($0)]
        EXCLUDE [open(...)] -->if [#_.close($0)]
    }

    PATTERN {
        UNSAFE  [_open(...)]
        EXCLUDE [_open(...)] -->if [_close($0)]
        EXCLUDE [_open(...)] -->if [#_.close($0)]
    }

    PATTERN {
        UNSAFE  [CreateFile(...)]
        EXCLUDE [CreateFile(...)] -->if [CloseHandle($0)]
        EXCLUDE [CreateFile(...)] -->if [#_.close($0)]
    }

    PATTERN {
        UNSAFE  [#AllocMem()]
        EXCLUDE [#AllocMem()] -->if [#FreeHeap($0)]
        EXCLUDE [#AllocMem()] -->if [#_.close($0)]
    }
}



// CWE-413 Improper Resource Locking
// [SP] 불충분한 자원 잠금
GROUP #PthreadMutexUnlock($1) {
    TEMPLATE #placeholder(..., $1, ...),

    pthread_mutex_unlock($1)
}

GROUP #"51230413".lock = #MutexLock
GROUP #"51230413".unlock = #MutexUnlock
RULE "51230413" {
    UNSAFE  [#_.lock($1)] <--if [#_.unlock($1)]
    EXCLUDE [#_.lock($1)] <--if [$0] in IFCOND
      <--if [#_.unlock($1)]
}



// CWE-414 Missing Lock Check
// [SP] 잠금 검사 누락
GROUP #"51230414".lock = #PthreadMutexLock
GROUP #"51230414".check($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51230414" {
    UNSAFE  [#_.lock($$)]
    EXCLUDE [#_.lock($$)] ==>rf [$0] in IFCOND
    EXCLUDE [#_.lock($$)] ==>rf [#_.check($0)]
}



/*
RULEID "51230415"
UNSAFE VSP[C,415]


RULEID "51230416"
UNSAFE VSP[C,416]
*/

// CWE-434 Unrestricted Upload of File with Dangerous Type
// [SP] 위험한 타입의 파일을 제약없이 업로드
GROUP #UploadFileName($1) {
    TEMPLATE #placeholder(..., $1, ...),

    cgiFormFileName("file"<STRING>, $1, $$)
}

GROUP #"51230434".upload = #UploadFileName
GROUP #"51230434".check = #StrCmpFunc
RULE "51230434" {
    UNSAFE  [#_.upload($$)]
    EXCLUDE [#_.upload($1)] -->rf [#_.check($1)] in IFCOND
}



//RULEID "51230457"
//UNSAFE VSP[C, 457]


//RULEID "51230466"
//UNSAFE VSP[C,466]


// CWE-470 Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')
// [SP] 안전하지 않은 리플렉션
GROUP #"51230470".source = #External
GROUP #"51230470".sink = #LDFunc
RULE "51230470" {
    UNSAFE [#_.source($1)] <--if [#_.sink($1)]
}



GROUP #InconsistFn() {
    TEMPLATE #placeholder(...),

    sysv_signal(...)
}

GROUP #"51230474".blacklist = #InconsistFn
RULE "51230474" {
    UNSAFE [#_.blacklist()]
}



// CWE-475 Undefined Behavior for Input to API
// [SP] 특정한 입력값만 동작하는 메서드
GROUP #UndefBehav() {
    TEMPLATE #placeholder(...),

    {{__\(
fxstat\(64\)?
\|lxstat\(64\)?
\|wcsto\(d\|f\|l\|ld\|ul\)_internal
\|xmknod
\|xstat\(64\)?
\)}}(...)
}

GROUP #"51230475".blacklist = #UndefBehav
RULE "51230475" {
    UNSAFE [#_.blacklist()]
}


// CWE-476 NULL Pointer Dereference
// [SP] 널포인터 역참조
// #include 5111.rdl RULE 51000476 51230476


GROUP #obsoleteFn() {
    TEMPLATE #placeholder(...),

    /SQLAlloc\(Connect\|Env\|Stmt\)\|getpw/(...)
}

GROUP #"51230477".blacklist = #obsoleteFn
RULE "51230477" {
    UNSAFE [#_.blacklist()]
}



// CWE-484 Omitted Break Statement in Switch
// [SP] Switch문에서 Break문 누락
RULE "51230484" {
    UNSAFE VSP[SASP, C,484]
}



// CWE-489 Leftover Debug Code
// [SP] 제거되지 않고 남은 디버그 코드
RULE "51230489" {
    PATTERN {
        UNSAFE [$<ARRAY, LIT /\(debug\|DEBUG\)/>] in IFCOND
    }
    PATTERN {
        UNSAFE [$<STRING, LIT /\(debug\|DEBUG\)/>] in IFCOND
    }
}


GROUP #Download($1) {
    TEMPLATE #placeholder(..., $1, ...),

    curl_easy_setopt($$, $<NAME CURLOPT_WRITEDATA>, $1)
}

GROUP #UseDownloadedFile($1) {
    TEMPLATE #placeholder(..., $1, ...),

    fgets($$, $$, $1)
}

GROUP #ReadForChecksum($1, $2) {
    TEMPLATE #placeholder($2, ..., $1, ...),

    fread($2, $$, $$, $1)
}

GROUP #ComputeChecksum($1, $2) {
    TEMPLATE #placeholder($2, ..., $1, ...),

    MD5_Update($2, $1, $$)
}

GROUP #GetChecksum($1, $2) {
    TEMPLATE #placeholder($2, ..., $1, ...),

    MD5_Final($2, $1)
}

GROUP #"51230494".download = #Download
GROUP #"51230494".use = #UseDownloadedFile
GROUP #"51230494".compare = #StrCmpFunc
RULE "51230494" {
    UNSAFE  [#_.download($1)] <--if [#_.use($1)]
    EXCLUDE [#_.download($1)]
      <--if [#ReadForChecksum($1, $2)]
      <--if [#ComputeChecksum($2, $3)]
      <--if [#GetChecksum($3, $4)]
      <--if [#_.compare($4)]
      <--if [#_.use($1)]
}


// CWE-497 Exposure of System Data to an Unauthorized Control Sphere
// [SP] 시스템 데이터 정보 누출
GROUP #GetSystemData() {
    TEMPLATE #placeholder(...),

    getenv(...)
}

GROUP #PutSystemData($1) {
    TEMPLATE #placeholder(..., $1, ...),

    getcwd($1, $$)
}

GROUP #"51230497".source1 = #GetSystemData
GROUP #"51230497".source2 = #PutSystemData
GROUP #"51230497".sink = #Output
GROUP #"51230497".sanitizer($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51230497" {
    PATTERN {
        UNSAFE  [#_.source1()] <--if [#_.sink($0)]
        EXCLUDE [#_.source1()] <--if [#_.sanitizer($0)] <--if [#_.sink($0)]
    }

    PATTERN {
        UNSAFE  [#_.source2($1)] <--if [#_.sink($1)]
        EXCLUDE [#_.source2($1)] <--if [#_.sanitizer($1)] <--if [#_.sink($0)]
    }
}



// FIXME: Rewrite neeeded.
// CWE-521 Weak Password Requirements
// [SP] 취약한  패스워드 요구조건
// #include 5111.rdl RULE 51000521 51230521


RULE "51230558" {
    UNSAFE [getlogin()]
}



//RULEID "51230562"
//UNSAFE  VSP[C,562]


// CWE-563 Unused Variable
// [SP] 사용되지 않는 변수
//RULEID "51230563"
//UNSAFE  VSP[C,563]


// CWE-570 Expression is Always False
// [SP] 항상 거짓인 논리식
RULE "51230570" {
    UNSAFE VSP[SASP, C,570]
}



// CWE-571 Expression is Always True
// [SP] 항상 참인 논리식
RULE "51230571" {
    UNSAFE VSP[SASP, C,571]
}



//RULEID "51230587"
//UNSAFE  VSP[C,587]


GROUP #"51230590".alloc = #Alloc
GROUP #"51230590".free = #FreeHeap
RULE "51230590" {
    UNSAFE  [#_.free($$)]
    EXCLUDE [#_.alloc()] <--if [#_.free($0)]
}



// CWE-601 URL Redirection to Untrusted Site ('Open Redirect')
// [SP] 신뢰되지 않는 URL 주소로의 자동 접속 연결
GROUP #"51230601".source = #CGI_Input
GROUP #"51230601".sink = #CGI_HeaderLocation
GROUP #"51230601".sanitizer($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51230601" {
    UNSAFE  [#_.source($1)] <--if [#_.sink($1)]
    EXCLUDE [#_.source($1)] <--if [#_.sanitizer($1)] <--if [#_.sink($1)]
}



// CWE-605 Multiple Binds to the Same Port
// [SP] 같은 포트번호로의 다중 연결
RULE "51230605" {
    PATTERN {
        UNSAFE AND[[setsockopt($1, $<NAME SOL_SOCKET>, $<NAME SO_REUSEADDR>, $$, $$)]
                   <--if [bind($1, $$, $$)];
                   [ASSIGN($2<NAME sin_addr.s_addr> := htonl($<NAME INADDR_ANY>))]
                   <--if [bind($$, $2, $$)]]
    }

    PATTERN {
        UNSAFE AND[[setsockopt($1, "0xffff"<INT>, "0x0004"<INT>, $$, $$)]
                   <--if [bind($1, $$, $$)];
                   [ASSIGN($2<NAME sin_addr.s_addr> := htonl("0x00000000"<CLASS in_addr_t>))]
                   <--if [bind($$, $2, $$)]]
    }

    PATTERN {
        UNSAFE [setsockopt($1, $$, $<NAME SO_REUSEADDR>, $$, $$)]
          -->cf [ASSIGN($2<NAME sin_port> := htons($<CONSTANT>))]
          -->if [bind($1, $2, $$)] in LOOPBODY
          -->if [accept($1, $$, $$)] in LOOPBODY
    }
}



// CWE-606 Unchecked Input for Loop Condition
// [SP] 루프 조건에서 미점검 입력 사용
GROUP #"51230606".input = #External
RULE "51230606" {
    UNSAFE [#_.input($1)] <--if [[$$, _<, $1, >_]] in LOOPCOND
}



// CWE-615 Information Exposure Through Comments
// [SP] 주석문 안에 포함된 시스템 주요정보
RULE "51230615" {
    PATTERN {
        UNSAFE CMT[
          "\(password\|passwd\|pwd\|pass\) *[=:-] *[a-zA-Z0-9][a-zA-Z0-9]*[ \\n]";
          "\(비밀번호\|비번\|패스워드\|암호\) *[=:-] *[a-zA-Z0-9][a-zA-Z0-9]*[ \\n]";
          "\(비밀번호는\|비번은\|패스워드는\|암호는\) *[a-zA-Z0-9][a-zA-Z0-9]*[ \\n]";
          "using password [a-zA-Z0-9][a-zA-Z0-9]*"
        ]
        EXCLUDE CMT["should pass "]
        EXCLUDE CMT["\(password\|passwd\|pwd\|pass\) *= *[a-zA-Z][a-zA-Z0-9.]*();"]
    }

    PATTERN {
        UNSAFE  CMT["\(password\|passwd\|pwd\|pass\)\( \|[a-zA-Z ]* \)is "]
        EXCLUDE CMT["\(password\|passwd\|pwd\|pass\)\( \|[a-zA-Z ]* \)is [a-z][a-z]*ed "]
        EXCLUDE CMT["\(password\|passwd\|pwd\|pass\)\( \|[a-zA-Z ]* \)is read from"]
        EXCLUDE CMT["passed [a-zA-Z ]* is"]
        EXCLUDE CMT["should pass "]
    }
}



// CWE-643 Improper Neutralization of Data within XPath Expressions ('XPath Injection')
// [SP] XPath 삽입
GROUP #XPathExecute($1) {
    TEMPLATE #placeholder(..., $1, ...),

    xmlXPathEvalExpression($1, ...)
}

GROUP #"51230643".source = #External
GROUP #"51230643".sink = #XPathExecute
RULE "51230643" {
    UNSAFE [#_.source($1)] <--if [#_.sink($1)]
}



// CWE-652 Improper Neutralization of Data within XQuery Expressions ('XQuery Injection')
// [SP] XQuery 삽입
GROUP #XQueryExecute($1) {
    TEMPLATE #placeholder(..., $1, ...),

    XQC_Implementation.prepare($$, $1, ...),
    XQC_Expression.execute($1, ...)
}

GROUP #"51230652".source = #External
GROUP #"51230652".sink = #XQueryExecute
RULE "51230652" {
    UNSAFE [#_.source($1)] <--if [#_.sink($1)]
}



// CWE-674 Uncontrolled Recursion
// [SP] 제대로 제어되지 않은 재귀
RULE "51230674" {
    UNSAFE VSP[SASP, Common, 674]
}



GROUP #Banned_string_copy() {
    TEMPLATE #placeholder(...),

    {{\(
l?[sS]tr[cC]py[AW]?
\|wcsn?cpy
\|_\(tcsn?\|mbsn?\|mbsnb\|tc\|mbc\|ftcs\)cpy
\|strncpy
\|StrCpyN[AW]?
\|StrNCpy[AW]?
\|strcpynA
\|lstrcpyn[AW]?
\)}}(...)
}

GROUP #Banned_string_concat() {
    TEMPLATE #placeholder(...),

    {{\(
l?[sS]tr[cC]at[AW]?
\|wcsn?cat
\|_\(tcs\|mbs\)cat
\|StrCatBuff[AW]?
\|StrCatChainW
\|_\(tc\|mbc\|ftcs\|tcsn\|mbsn\|mbsnb\)cat
\|l?strncat
\|StrCatN[AW]?
\|StrNCat[AW]?
\|lstrcatn[AW]?
\)}}(...)
}

GROUP #Banned_sprintf() {
    TEMPLATE #placeholder(...),

    {{\(
w?sprintf[AW]?
\|swprintf
\|_v?stprintf
\|wvsprintf[AW]?
\|vsw?printf
\)}}(...)
}

GROUP #Banned_sprintf_recommended() {
    TEMPLATE #placeholder(...),

    {{\(
wnsprintf[AW]?
\|_snwprintf
\|snt?printf
\|_?vsnprintf
\|_vsn[wt]printf
\|wvnsprintf[AW]?
\)}}(...)
}

GROUP #Banned_n_sprintf_recommmeded() {
    TEMPLATE #placeholder(...),

    {{\(
_sn[wt]?printf
\|nsprintf
\)}}(...)
}

GROUP #Banned_va_sprintf() {
    TEMPLATE #placeholder(...),

    {{\(
wvsprintf[AW]?
\|vsw?printf
\|_vstprintf
\)}}(...)
}

GROUP #Banned_va_n_sprintf_recommended() {
    TEMPLATE #placeholder(...),

    {{\(
_vsn[wt]?printf
\|wvnsprintf[AW]?
\)}}(...)
}

GROUP #Banned_n_string_copy() {
    TEMPLATE #placeholder(...),

    {{\(
\(str\|wcs\)ncpy
\|_\(tcsn\|mbsn\|mbsnb\|fstrn\)cpy
\|StrCpyN[AW]?
\|strcpynA
\|StrNCpy[AW]?
\|lstrcpyn[AW]?
\)}}(...)
}

GROUP #Banned_n_string_concat() {
    TEMPLATE #placeholder(...),

    {{\(
\(str\|wcs\)ncat
\|_\(tcsn\|mbsn\|mbsnb\|fstrn\)cat
\|StrCatN[AW]?
\|StrNCat[AW]?
\|lstrncat
\|lstrcatn[AW]?
\)}}(...)
}

GROUP #Banned_string_tokenizing_recommended() {
    TEMPLATE #placeholder(...),

    {{\(
\(str\|_tcs\|wcs\)tok
\|_mbsto
\)}}(...)
}

GROUP #Banned_makepath_recommended() {
    TEMPLATE #placeholder(...),

    /\(_t\|_\|_w\)?makepath/(...)
}

GROUP #Banned_splitpath_recommended() {
    TEMPLATE #placeholder(...),

    /_[tw]?splitpath/(...)
}

GROUP #Banned_scanf_recommended() {
    TEMPLATE #placeholder(...),

    /\(w\|_t\|s\|sw\|_st\)?scanf/(...)
}

GROUP #Banned_n_scanf_recommended() {
    TEMPLATE #placeholder(...),

    /\(sn\|snw\|_snt\)scanf/(...)
}

GROUP #Banned_numeric_conversion_recommended() {
    TEMPLATE #placeholder(...),

    /_i\(64\)?to[aw]/(...),
    /_u\(i64\|l\)to[atw]/(...)
}

GROUP #Banned_gets() {
    TEMPLATE #placeholder(...),

    /\(gets\|_getts\|_gettws\)/(...)
}

GROUP #Banned_IsBad() {
    TEMPLATE #placeholder(...),

    /IsBad\(Write\|HugeWrite\|Read\|HugeRead\|Code\|String\)Ptr/(...)
}

GROUP #Banned_OEM_conversion_recommended() {
    TEMPLATE #placeholder(...),

    /\(CharToOem\|OemToChar\|CharToOemBuff\)[AW]?/(...)
}

GROUP #Banned_stack_dynamic_malloc_recommended() {
    TEMPLATE #placeholder(...),

    /_?alloca/(...)
}

GROUP #Banned_string_length_recommended() {
    TEMPLATE #placeholder(...),

    /\(\(str\|wcs\|_mbs\|_mbstr\|lstr\)len\|StrLen\)/(...)
}

GROUP #Banned_memory_copy() {
    TEMPLATE #placeholder(...),

    /\(w?memcpy\|RtlCopyMemory\|CopyMemory\)/(...)
}

GROUP #Banned_window_messaging_recommended() {
    TEMPLATE #placeholder(...),

    ChangeWindowMessageFilter(...)
}

GROUP #"51230676".blacklist() {
    TEMPLATE #placeholder(...),

    #Banned_string_copy,
    #Banned_string_concat,
    #Banned_sprintf,
    #Banned_sprintf_recommended,
    #Banned_n_sprintf_recommmeded,
    #Banned_va_sprintf,
    #Banned_va_n_sprintf_recommended,
    #Banned_n_string_copy,
    #Banned_n_string_concat,
    #Banned_string_tokenizing_recommended,
    #Banned_makepath_recommended,
    #Banned_splitpath_recommended,
    #Banned_scanf_recommended,
    #Banned_n_scanf_recommended,
    #Banned_numeric_conversion_recommended,
    #Banned_gets,
    #Banned_IsBad,
    #Banned_OEM_conversion_recommended,
    #Banned_stack_dynamic_malloc_recommended,
    #Banned_string_length_recommended,
    #Banned_memory_copy,
    #Banned_window_messaging_recommended,
}

RULE "51230676" {
    UNSAFE [#_.blacklist()]
}



RULE "51230685" {
    UNSAFE VSP[SASP, C,685]
}



RULE "51230686" {
    UNSAFE VSP[SASP, C,686]
}



// CWE-732 Incorrect Permission Assignment for Critical Resource
// 중요한 자원에 대한 잘못된 권한 설정
RULE "51230732" {
    UNSAFE [umask("0"<INT>)] -->rf [fopen($$, "w"<STRING>)]
}



// CWE-754 Improper Check for Unsual Conditions
// 적절하지 않은 예외처리

// beSOURCE: Too slow. Must be reimplemented.
IF !(product == "beSOURCE") THEN
GROUP #CheckableFunc() {
    TEMPLATE #placeholder(...),

   {{\(
[fs]?w?scanf
\|fwrite
\|f?putw?c
\|putchar
\|f?putw?s
\|\(w\|_w\)?remove
\|\(w\|_w\)?rename
\|_snw?printf
\|Create\(Mutex\|NamedPipe\)[AW]
\|Impersonate\(NamedPipeClient\|Self\)
\|fgetw?s
\|fw?printf
\|fread
\|RpcImpersonateClient
\|putwchar
\|_putws
\)}}(...)
}

GROUP #"51230754".checkable = #CheckableFunc
GROUP #"51230754".check($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51230754" {
    UNSAFE  [#_.checkable()]
    EXCLUDE [#_.checkable()@checked] in IF<NOT EMPTY>
    EXCLUDE [#_.checkable()] -->df [$0@checked] in IF<NOT EMPTY>
    EXCLUDE [#_.checkable()] -->df [#_.check($0)]
}

ENDIF


// CWE-759 Use of a One-Way Hash without a Salt
// 솔트 없이 일방향 해쉬 함수 사용
GROUP #HashWithoutSalt() {
    TEMPLATE #placeholder(...),

    crypt($$),
    KrdMD5Encrypt($$, "0"<INT>)
}

GROUP #"51230759".blacklist = #HashWithoutSalt
RULE "51230759" {
    PATTERN {
        UNSAFE [simple_digestj(...)] -->if [$0] in IFCOND
    }

    PATTERN {
        UNSAFE [#_.blacklist()]
    }
}


GROUP #"51230775".open = #FOpen
GROUP #"51230775".close = #FClose
RULE "51230775" {
    UNSAFE  [#_.open()]
    EXCLUDE [#_.open()] -->if  [#_.close($0)]
}


// CWE-789 Uncontrolled Memory Allocation
// [SP] 제어되지 않은 메모리 할당
GROUP #"51230789".source = #External
GROUP #"51230789".sink = #UnsignedAllocFunc
GROUP #"51230789".sanitizer($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51230789" {
    UNSAFE  [#_.source($1)] <--if [#_.sink($1)]
    EXCLUDE [#_.source($1)] <--if [#_.sanitizer($1)]
      <==df [#_.sink($1)]
}


// FIXME: IF..ENDIF in RULE
// beSOURCE: awful performance due to [[$1, _<, $$, >_]] in IFCOND
IF !(product == "beSOURCE") THEN
// TODO: @checked?
ADD-EXCLUDE "51230789" {
    [#_.source($1)] <--if [[$1, _<, $$, >_]] in IFCOND <==df [#_.sink($1)]
}
ENDIF


// CWE-807 Reliance on Untrusted Inputs in a Security Decision
// 보호메커니즘을 우회할 수 있는 입력값 변조
RULE "51230807" {
    PATTERN {
        UNSAFE AND[
               [gethostbyaddr(...)] <--if [#StrCmp($0, $$)] in IFCOND;
               [#External($1)] <--if [#StrCmp($$, $1)] in IFCOND
        ]
    }

    PATTERN {
        UNSAFE AND[
               [gethostbyaddr(...)] <--if [#StrCmp($0, $$)] in IFCOND;
               [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
         <--if [#RECV($1, $2)] <--if [#StrCmp($$, $2)] in IFCOND
        ]
    }

    PATTERN {
        UNSAFE AND[
               [cgiFormString($$, $1, $$)] <--if [#StrCmp($1, $$)] in IFCOND;
               [#External($1)] <--if [#StrCmp($$, $1)] in IFCOND
        ]
    }

    PATTERN {
        UNSAFE AND[
               [cgiFormString($$, $1, $$)] <--if [#StrCmp($1, $$)] in IFCOND;
               [ASSIGN($1 := socket(...))] <--if [#CONNECT($1)]
         <--if [#RECV($1, $2)] <--if [#StrCmp($$, $2)] in IFCOND
        ]
    }

    PATTERN {
        UNSAFE [gethostbyaddr(...)] in FUNCTION<decision>
         <--if [#StrCmp($0, $$)] in IFCOND in FUNCTION<decision>
    }
}



//
// [SP] LDAP 처리
GROUP #"51239106".source = #External
GROUP #"51239106".sink = #LDAPfunction
GROUP #"51239106".sanitizer($1) {
    TEMPLATE #placeholder(..., $1, ...)
}

RULE "51239106" {
    UNSAFE  [#_.source($1)] <--if [#_.sink($1,$$)]
    EXCLUDE [#_.source($1)] <--if [#_.sanitizer($1)] <--rf [#_.sink($1,$$)]
}



//RULEID "51239116"
//UNSAFE VSP[C,9116]


//RULEID "51239117"
//UNSAFE VSP[C,9117]


GROUP #UnsignedArgFunc($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(mem\(cmp\|cpy\|move\)\|str\(lcat\|lcpy\|ncat\|ncmp\|ncpy\)\)/($$,$$,$1),
    /\(memset\|strnlen\)/($$,$1)
}

GROUP #"51239118".unsigned = #UnsignedArgFunc
RULE "51239118" {
    UNSAFE [#_.unsigned($<SIGNED>)]
}



//RULEID "51239119"
//UNSAFE VSP[C,9119]


RULE "51239120" {
    UNSAFE VSP[SASP, C,9120]
}



GROUP #DBConU($1) {
    TEMPLATE #placeholder(..., $1, ...),

    /\(OCILogon2?\|SQLConnect\)/($$, $$, $$, $1, ...),
    mysql_real_connect($$, $$, $1, ...)
}

GROUP #"51239301".username = #DBConU
RULE "51239301" {
    UNSAFE [#_.username($<CONSTANT>)]
}



//
// [SP] 주석문 안에 포함된 패스워드
RULE "51239302" = "51230615"


//
// [SP] 취약한 암호화 해쉬함수: 하드코드된 솔트
GROUP #Encrypt($1) {
    TEMPLATE #placeholder(..., $1, ...),

    crypt($$, $1)
}

GROUP #"51239307".salt = #Encrypt
RULE "51239307" {
    UNSAFE [#_.salt($<CONSTANT>)]
}



//
// [SP] 취약한 암호화: 적절하지 못한 RSA 패딩
GROUP #RSAEncNP($1) {
    TEMPLATE #placeholder(..., $1, ...),

    RSA_public_encrypt($$, $$, $$, $$, $1)
}

RULE "51239309" {
    PATTERN {
        UNSAFE [#RSAEncNP("RSA_NO_PADDING"<STRING>)]
    }

    PATTERN {
        UNSAFE [ASSIGN($1 := $<NAME RSA_NO_PADDING>)] <--rf [#RSAEncNP($1)]
    }
}



// CWE-326 Inadequate Encryption Strength
// [SP] 충분하지 않은 키 길이 사용
GROUP #"51239310".blacklist = #InadequateEncrypt
RULE "51239310" {
    UNSAFE [#_.blacklist()]
}



GROUP #PthreadCondSignal() {
    TEMPLATE #placeholder(...),

    pthread_cond_signal(...)
}

GROUP #"51239407".lock = #PthreadMutexLock
GROUP #"51239407".unlock = #PthreadMutexUnlock
GROUP #"51239407".cond = #PthreadCondSignal
RULE "51239407" {
    UNSAFE  [#_.lock($$)] <--cf [#_.cond()]
    EXCLUDE [#_.unlock($$)] <--cf [#_.cond()]
}



RULE "51239607" {
    UNSAFE VSP[SASP, C,9607]
}



RULE "51239614" {
    UNSAFE VSP[SASP, C,9614]
}



// Code Correctness: Function Not Invoked
// [SP] 함수 호출이 되지 않음
RULE "51239615" {
    UNSAFE VSP[SASP, C,9615]
}



// Poor Style: Redundant Initialization
// [SP] 불필요한 초기화
//RULEID "51239616"
//UNSAFE VSP[C,9616]


RULE "51239617" {
    UNSAFE VSP[SASP, C,9617]
}



RULE "51239618" {
    PATTERN {
        UNSAFE  [pthread_cleanup_push(...)]
        EXCLUDE [pthread_cleanup_push(...)]  ==>cf [pthread_cleanup_pop(...)]
    }

    PATTERN {
        UNSAFE  [pthread_cleanup_pop(...)]
        EXCLUDE [pthread_cleanup_push(...)]  <==cf [pthread_cleanup_pop(...)]
    }

    PATTERN {
        UNSAFE  [_pthread_cleanup_push(...)]
        EXCLUDE [_pthread_cleanup_push(...)] ==>cf [_pthread_cleanup_pop(...)]
    }

    PATTERN {
        UNSAFE  [_pthread_cleanup_pop(...)]
        EXCLUDE [_pthread_cleanup_push(...)]  <==cf [_pthread_cleanup_pop(...)]
    }
}



//RULEID "51239619"
//UNSAFE VSP[C,9619]

RULE "51239620" {
    UNSAFE  [pthread_create(...)]
    EXCLUDE [pthread_create($1, ...)]
      ==>rf [/pthread_\(join\|detach\)/($1, ...)]
    EXCLUDE [pthread_attr_setdetachstate($2, $<NAME PTHREAD_CREATE_DETACHED>)]
      <==rf [pthread_create($$, $2, ...)]
    EXCLUDE [pthread_attr_setdetachstate($2, "1"<INT>)]
      <==rf [pthread_create($$, $2, ...)]
}



// #include 5111.rdl GROUP IsBadXXXPtr
// #include 5111.rdl RULE 51009621 51239621

RULE "51239622" {
    UNSAFE VSP[SASP, C,9622]
}



// Memory Leak: Reallocation
// Reallocation 사용시 메모리 누수
RULE "51239623" {
    UNSAFE [realloc(...)]
}


//////////////////////////////////////////////////////////////////////////////
// CSP
//////////////////////////////////////////////////////////////////////////////

RULE "51238129" {
    UNSAFE VSP[CSP, "buffer_overflow"]
}

RULE "51238369" {
    UNSAFE VSP[CSP, "div_by_zero"]
}

RULE "51238401" {
    UNSAFE VSP[CSP, "leak"]
}

RULE "51238404" {
    UNSAFE VSP[CSP, "free_nonheap"]
}

RULE "51238415" {
    UNSAFE VSP[CSP, "double_free"]
}

RULE "51238416" {
    UNSAFE VSP[CSP, "dang_deref"]
}

RULE "51238457" {
    UNSAFE VSP[CSP, "uninit"]
}

RULE "51238476" {
    UNSAFE VSP[CSP, "null_deref"]
}

RULE "51238562" {
    UNSAFE VSP[CSP, "ret_stack"]
}


CUSTOM "CSP" {{{

////////////////////////////////////////////////////////////////////////
// CSP: Typedefs

typedef unsigned long size_t;
typedef unsigned long rsize_t;
typedef void *locale_t;
typedef unsigned long ssize_t;
typedef void *FILE;

////////////////////////////////////////////////////////////////////////
// CSP: stdlib.h

void *malloc(size_t size) = %malloc(size);
void *realloc(void *ptr, size_t size) = %realloc(ptr, size);
void *alloca(size_t size) = %alloca(size);
void *calloc(size_t n, size_t size) = %calloc(n, size);
void free(void *ptr) = %free(ptr);

int atoi(const char *s) {
    %use_string(s);
    i = %unsafe_int();
    return i;
}

int atoi_l(const char *s, locale_t loc) {
    %use_string(s);
    i = %unsafe_int();
    return i;
}

long atol(const char *s) {
    %use_string(s);
    i = %unsafe_int();
    return i;
}

long atol_l(const char *s, locale_t loc) {
    %use_string(s);
    i = %unsafe_int();
    return i;
}

long long atoll(const char *s) {
    %use_string(s);
    i = %unsafe_int();
    return i;
}

long long atoll_l(const char *s, locale_t loc) {
    %use_string(s);
    i = %unsafe_int();
    return i;
}

int abs(int i) {
    a = %abs(i);
    return a;
}

long long llabs(long long x) {
    a = %abs(x);
    return a;
}

long labs(long x) {
    a = %abs(x);
    return a;
}

double fabs(double x) {
    a = %abs(x);
    return a;
}

long double fabsl(long double x) {
    a = %abs(x);
    return a;
}

float fabsf(float x) {
    a = %abs(x);
    return a;
}

////////////////////////////////////////////////////////////////////////
// CSP: String

char *strcpy(char *restrict dst, const char* restrict src) = %strcpy(dst, src);
char *strncpy(char *restrict dst, const char* restrict src, size_t n)
    = %strncpy(dst, src, n);
void bzero(void *s, size_t n) = %bzero(s, n);
int memcmp(const void *s1, const void *s2, size_t n) = %memcmp(s1, s2, n);
void *memcpy(void *restrict dst, const void *restrict src, size_t n) = %memcpy(dst, src, n);
void *memset(void *s, int c, size_t len) = %memset(s, c, len);
size_t strlen(const char *s) = %strlen(s);
size_t wcslen(const wchar_t *s) = %strlen(s);

char *strpbrk(const char *s, const char *charset) {
    %use_string(s);
    %use_string(charset);
    p = %null_or_string(1);
    return p;
}

wchar_t *wcspbrk(const wchar_t *s, const wchar_t *charset) {
    %use_string(s);
    %use_string(charset);
    p = %null_or_string(1);
    return p;
}

size_t strspn(const char *s, const char *charset) {
    %use_string(s);
    %use_string(charset);
    l = %strlen(s);
    r = %int(0, s);
    return r;
}

size_t strcspn(const char *s, const char *charset) {
    %use_string(s);
    %use_string(charset);
    l = %strlen(s);
    r = %int(0, s);
    return r;
}

size_t wcsspn(const wchar_t *s, const wchar_t *charset) {
    %use_string(s);
    %use_string(charset);
    l = %strlen(s);
    r = %int(0, s);
    return r;
}

size_t wcscspn(const wchar_t *s, const wchar_t *charset) {
    %use_string(s);
    %use_string(charset);
    l = %strlen(s);
    r = %int(0, s);
    return r;
}

////////////////////////////////////////////////////////////////////////
// CSP: stdio.h

int printf(const char* restrict @outfmt fmt, ...) {
    %use_string(fmt);
    %use_string(%vargs);
    %use_fmt_args(fmt, %vargs);
    r = %arbitrary_int();
    return r;
}

int fprintf(FILE *restrict stream, const char* restrict @outfmt fmt, ...) {
    %deref(stream);
    %use_string(fmt);
    %use_string(%vargs);
    %use_fmt_args(fmt, %vargs);
    r = %arbitrary_int();
    return r;
}

int sprintf(char *restrict buf, const char* restrict @outfmt fmt, ...) {
    %deref(buf);
    %use_string(fmt);
    %use_string(%vargs);
    %use_fmt_args(fmt, %vargs);
    l = %fmt_len(fmt, %vargs);
    l = l + 1;
    %update_array(buf, 0, l);
    r = %arbitrary_int();
    return r;
}

int scanf(const char* restrict @infmt fmt, ...) {
    %use_string(fmt);
    %update(%vargs);
    r = %arbitrary_int();
    return r;
}

int sscanf(const char *restrict s, const char* restrict @infmt fmt, ...) {
    %use_string(s);
    %use_string(fmt);
    %update(%vargs);
    r = %arbitrary_int();
    return r;
}

int fscanf(FILE *restrict stream, const char* restrict @infmt fmt, ...) {
    %deref(stream);
    %use_string(fmt);
    %update(%vargs);
    r = %arbitrary_int();
    return r;
}

////////////////////////////////////////////////////////////////////////
// CSP: sys/socket.h

ssize_t recv(int socket, void *buf, size_t len, int flags) {
    %update_array(buf, 0, len);
    r = %arbitrary_int();
    return r;
}

}}}


//////////////////////////////////////////////////////////////////////////////
// ECP
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BSSC 10: Make sure that any code which you use for debugging purposes
// does not have side effects

RULE "51233873" {
    UNSAFE VSP[ECP, "debug_sideeffect"]
}


//////////////////////////////////////////////////////////////////////////////
// BSSC 26: Source code shall be separated into a public interface (the
// ".h" file) and a private implementation (the ".c" file).

// RULE "?" {
//    UNSAFE VSP[ECP, "header_implementation"]
// }

//////////////////////////////////////////////////////////////////////////////
// BSSC 27: The interface file must be included in its own corresponding
// implementation file.

RULE "51233872" {
    UNSAFE VSP[ECP, "include_header"]
}


//////////////////////////////////////////////////////////////////////////////
// BSSC 63: A parameter, which is not changed by the function, should be
// declared 'const'.

RULE "51233869" {
    UNSAFE VSP[ECP, "const_param"]
    OPTION mode = "fast"
    OPTION dest = "general"
    OPTION exclude = ["argc"]
}


//////////////////////////////////////////////////////////////////////////////
// BSSC 66: A function may not return a reference or pointer to one of its own
// local automatic variables.

RULE "51233857" {
    PATTERN {
        // UNSAFE VSP[ECP, "ret_stack_addr_simple"]
        UNSAFE VSP[ECP, "unit"]
    }
    PATTERN {
        // UNSAFE VSP[ECP, "out_of_scope_obj_simple"]
        UNSAFE VSP[ECP, "unit"]
    }
}


//////////////////////////////////////////////////////////////////////////////
// BSSC 81: Member functions, which do not alter the state of an object, shall
// be declared 'const'.

RULE "51233858" {
    UNSAFE VSP[ECP, "const_method"]
}

//////////////////////////////////////////////////////////////////////////////
// BSSC 82: Public member functions must not return non-const references or
// pointers to member variables of an object.

RULE "51233851" {
    UNSAFE VSP[ECP, "member_func_nonconst"]
}

//////////////////////////////////////////////////////////////////////////////
// BSSC 83: A function may not return a reference to memory, which it has
// allocated.

// TODO: Migrate to SASP.
RULE "51233859" {
    UNSAFE VSP[ECP, "unit"]
    // UNSAFE VSP[ECP, "malloc_return"]
}

//////////////////////////////////////////////////////////////////////////////
// BSSC 88: A function which can issue exceptions (i.e. has a "throw") clause
// in its declaration) can only be called.

RULE "51233860" {
    UNSAFE VSP[ECP, "uncaughted_exception"]
}

//////////////////////////////////////////////////////////////////////////////
// BSSC 92: Conditional expressions must always compare against an explicit
// value.

RULE "51233870" {
    UNSAFE VSP[ECP, "explicit_test_for_func"]
    OPTION zerotest = "false"
}


//////////////////////////////////////////////////////////////////////////////
// BSSC 93: The programmer shall make sure that the order of evaluation of the
// expression is defined by typing in the appropriate syntax

RULE "51233861" {
    UNSAFE VSP[ECP, "depend_order"]
}


//////////////////////////////////////////////////////////////////////////////
// BSSC 99: The return values of memory handling routines must always be
// checked.

RULE "51233862" {
    PATTERN {
        UNSAFE VSP[SASP, C, 3083]
        OPTION function = ["aligned_alloc", "calloc", "realloc", "malloc"]
    }
}


//////////////////////////////////////////////////////////////////////////////
// BSSC 100: Dynamic memory allocated using malloc() should be returned to the
// system using free().

RULE "51233863" {
    UNSAFE VSP[ECP, "malloc_free"]
}


//////////////////////////////////////////////////////////////////////////////
// BSSC 101: The programmer must ensure that a pointer to dynamic memory is
// not lost when using realloc().

RULE "51233864" {
    UNSAFE VSP[SASP, C, 3864]
}


//////////////////////////////////////////////////////////////////////////////
// BSSC 106: The return values of library functions should be checked for
// errors.

// FIXME: Duplicated to 51233058.
RULE "51233865" {
    PATTERN {
        UNSAFE VSP[SASP, C, 3083]
        OPTION function = [
            "fopen", "gets", "fgets", "aligned_alloc",
            "bsearch", "bsearch_s", "calloc", "freopen",
            "getenv", "getenv_s", "gets_s", "gmtime", "gmtime_s",
            "realloc", "localtime", "localtime_s", "malloc", "memchr",
            "setlocale", "strchr", "strpbrk", "strrchr", "strstr",
            "strtok", "strtok_s", "tmpfile", "tmpnam", "wcschr",
            "wcspbrk", "wcsrchr", "wcsstr", "wcstok", "wcstok_s",
            "wmemchr", "fmemopen", "open_memstream", "posix_memalign",
            "fseek", "snprintf"
        ]
    }

    // p = relloc(p, ...)
    PATTERN {
        UNSAFE VSP[SASP, C, 3864]
    }
}


//////////////////////////////////////////////////////////////////////////////
// BSSC 107: Diagnostic code should be added to all areas of code which
// 'should never be executed'.

RULE "51233874" {
    UNSAFE VSP[ECP, "empty_default"]
}


//////////////////////////////////////////////////////////////////////////////
// BSSC 112: Macros should not be used with expressions containing side
// effects.

RULE "51233866" {
    UNSAFE VSP[ECP, "macro_sideeffect"]
    OPTION mode = "fast"
    OPTION target = "always"
}


//////////////////////////////////////////////////////////////////////////////
// BSSC 118: The programmer may not assume that different data types have
// equivalent representations in memory.

RULE "51233852" {
    UNSAFE VSP[ECP, "memcmp_struct_pointer"]
    OPTION different = "true"
}


//////////////////////////////////////////////////////////////////////////////
// BSSC 119: The programmer may not assume knowledge of how different data
// types are aligned in memory.

RULE "51233867" {
    UNSAFE VSP[ECP, "bitfield_align"]
}


//////////////////////////////////////////////////////////////////////////////
// BSSC 120: The programmer may not assume that pointers to different data
// types are equivalent.

RULE "51233853" {
    UNSAFE VSP[ECP, "cast_pointer"]
    OPTION mode = "basic"
}


//////////////////////////////////////////////////////////////////////////////
// BSSC 121: The programmer may not mix pointer and integer arithmetic.

RULE "51233854" {
    UNSAFE VSP[ECP, "pointer_not_int"]
}


//////////////////////////////////////////////////////////////////////////////
// BSSC 122: The programmer must use a wider type or unsigned values when
// testing for underflow or overflow.

RULE "51233855" {
    UNSAFE VSP[ECP, "not_large_type_under_over_check"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ PRE31-CPP. Avoid side-effects in arguments to unsafe macros

RULE "51233225" {
    UNSAFE VSP[ECP, "macro_sideeffect"]
    OPTION mode = "fast"
    OPTION target = "unsafe"
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ ARR01-CPP. Do not apply the sizeof operator to a pointer when
// taking the size of an array

// No rule
// #include 5111.rdl RULE 51003002 51233001

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ ARR33-CPP. Use consistent array notation across all source files

RULE "51233005" {
    UNSAFE VSP[ECP, "typ_chk_extern"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ CTR56-CPP. Do not use pointer arithmetic on polymorphic objects

RULE "51233013" {
    UNSAFE VSP[ECP, "array_polymorphically"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ VOID CTR41-CPP. A container's allocator should never have a data
// field that is not static

RULE "51233014" {
    UNSAFE VSP[ECP, "allocator_static"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ VOID CTR42-CPP. Never modify a set or multiset key in-place

RULE "51233015" {
    UNSAFE VSP[ECP, "modify_iterator"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ CTR58-CPP. Predicate function objects should not be mutable

RULE "51233016" {
    UNSAFE VSP[ECP, "dynamic_field"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ DCL13-CPP. Declare function parameters that are pointers to values
// not changed by the function as const

RULE "51233031" {
    UNSAFE VSP[ECP, "const_param"]
    OPTION dest = "pointer"
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ DCL14-CPP. Avoid assumptions about the initialization order
// between translation units

RULE "51233032" {
    UNSAFE VSP[ECP, "global_init_sideeffect"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ DCL15-CPP. Declare file-scope objects or functions that do not
// need external linkage in an unnamed namespace

RULE "51233251" {
    UNSAFE VSP[ECP, "external_linkages_notneed"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ DCL20-CPP. Use volatile for data that cannot be cached

RULE "51233039" {
    UNSAFE VSP[ECP, "global_in_handlers"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ EXP01-CPP. Do not take the size of a pointer to determine the size
// of the pointed-to type

RULE "51233067" {
    UNSAFE VSP[ECP, "sizeof_pointer_check"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ EXP03-CPP. Do not assume the size of a class or struct is the sum
// of the sizes of its members

RULE "51233069" {
    UNSAFE VSP[ECP, "strct_padding_size_chk"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ EXP08-CPP. Ensure pointer arithmetic is used correctly

// TODO: Replace with CSP.
RULE "51233073" {
    // UNSAFE VSP[ECP, "dang_deref_simple"]
    // OPTION type = "invalid"
    // UNSAFE VSP[ECP, "arr_idx_out_simple"]
    // OPTION mode = "pointer"
    UNSAFE VSP[ECP, "unit"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ EXP62-CPP. Do not access the bits of an object representation that
// are not part of the object's value representation

RULE "51233070" {
    UNSAFE VSP[ECP, "memcmp_struct_pointer"]
    OPTION aggregate = "true"
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ EXP52-CPP. Do not rely on side effects in unevaluated operands

RULE "51233071" {
    UNSAFE VSP[ECP, "operand_sideeffect"]
    OPTION rule = "CERT"
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ EXP54-CPP. Do not access an object outside of its lifetime

// FIXME: Duplicated to 51233857.
RULE "51233037" {
    PATTERN {
        // UNSAFE VSP[ECP, "ret_stack_addr_simple"]
        UNSAFE VSP[ECP, "unit"]
    }
    PATTERN {
        // UNSAFE VSP[ECP, "out_of_scope_obj_simple"]
        UNSAFE VSP[ECP, "unit"]
    }
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ EXP50-CPP. Do not depend on the order of evaluation for side
// effects

RULE "51233075" {
    UNSAFE VSP[ECP, "double_sideeffect_exp_fast"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ EXP14-CPP. Do not use reinterpret_cast on pointers to class
// objects with multiple inheritance

RULE "51233078" {
    UNSAFE VSP[ECP, "reinterpret_cast"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ EXP02-CPP. Be aware of the short-circuit behavior of the logical
// AND and OR operators

RULE "51233068" {
    UNSAFE VSP[ECP, "logical_op_sideeffect"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ EXP50-CPP. Do not depend on the order of evaluation for side
// effects

RULE "51233082" {
    UNSAFE VSP[ECP, "depend_order"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C EXP32-C. Do not access a volatile object through a non-volatile
// reference

RULE "51233084" {
    UNSAFE VSP[ECP, "volatile_to_nonvol_chk"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C EXP34-C. Do not dereference null pointer

// DEPRECATED: Use CSP.
RULE "51233086" {
    // UNSAFE VSP[ECP, "null_deref_simple"]
    UNSAFE VSP[ECP, "unit"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ EXP55-CPP. Do not access a cv-qualified object through a
// cv-unqualified type

RULE "51233087" {
    UNSAFE VSP[ECP, "const_casting"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ EXP36-C. Do not cast pointers into more strictly aligned pointer
// types

RULE "51233088" {
    UNSAFE VSP[SASP, C, 3095]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ EXP57-CPP. Do not cast or delete pointers to incomplete classes

RULE "51233090" {
    UNSAFE VSP[ECP, "delete_class"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ INT00-CPP. Understand the data model used by your
// implementation(s)

RULE "51233137" {
    UNSAFE VSP[ECP, "int_size"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ INT01-CPP. Use rsize_t or size_t for all integer values
// representing the size of an object

RULE "51233138" {
    UNSAFE VSP[ECP, "sizeof_param_typ_chk"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ INT02-CPP. Understand integer conversion rules

RULE "51233139" {
    UNSAFE VSP[ECP, "understand_integer"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ INT04-CPP. Enforce limits on integer values originating from
// untrusted sources

// TODO: Migrate to SASP.
RULE "51233141" {
    UNSAFE VSP[ECP, "unit"]
    // UNSAFE VSP[ECP, "taint_analysis"]
    // OPTION rule = "INT+04"
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ INT07-CPP. Use only explicitly signed or unsigned char type for
// numeric values

RULE "51233144" {
    UNSAFE VSP[SASP, C, 3030]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ INT11-CPP. Take care when converting from pointer to integer or
// integer to pointer

RULE "51233148" {
    UNSAFE VSP[ECP, "int_ptr_conv"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ INT12-CPP. Do not make assumptions about the type of a plain int
// bit-field when used in an expression

RULE "51233149" {
    UNSAFE VSP[ECP, "bitfld_typ_assumption_chk"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ INT13-CPP. Use bitwise operators only on unsigned operands

RULE "51233150" {
    UNSAFE VSP[ECP, "only_uint_bitwise"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ INT14-CPP. Avoid performing bitwise and arithmetic operations on
// the same data

RULE "51233151" {
    UNSAFE VSP[SASP, C, 3124]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ INT15-CPP. Use intmax_t or uintmax_t for formatted IO on
// programmer-defined integer types

RULE "51233152" {
    UNSAFE VSP[ECP, "printf_typ_casting_chk"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ INT18-CPP. Evaluate integer expressions in a larger size before
// comparing or assigning to that size

RULE "51233160" {
    UNSAFE VSP[ECP, "smaller_type"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C INT33-C. Ensure that division and remainder operations do not
// result in divide-by-zero errors

// DEPRECATED: Use CSP.
RULE "51233158" {
    // UNSAFE VSP[ECP, "div_by_zero_simple"]
    UNSAFE VSP[ECP, "unit"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C INT34-C. Do not shift an expression by a negative number of bits or
// by greater than or equal to the number of bits that exist in the operand

RULE "51233159" {
    UNSAFE VSP[ECP, "shift_simple"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ INT50-CPP. Do not cast to an out-of-range enumeration value

RULE "51233161" {
    UNSAFE VSP[ECP, "enum_range_simple"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ FLP02-CPP. Avoid using floating point numbers when precise
// computation is needed

RULE "51233127" {
    UNSAFE VSP[ECP, "float_equality"]
    OPTION mode = "general"
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ FLP03-CPP. Detect and handle floating point errors

RULE "51233128" {
    UNSAFE VSP[ECP, "float_func"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ FLP30-C. Do not use floating-point variables as loop counters

RULE "51233130" {
    UNSAFE VSP[ECP, "loop_float"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ VOID FLP31-CPP. Do not call functions expecting real values with
// complex values

RULE "51233131" {
    UNSAFE VSP[ECP, "complex_incompatible_func"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ FLP33-CPP. Convert integers to floating point for floating point
// operations

RULE "51233133" {
    UNSAFE [ASSIGN($<FLOAT> := ($<INT>, [+, -, /, *], $<INT>))]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C FLP34-C. Ensure that floating-point conversions are within range of
// the new type

RULE "51233134" {
    UNSAFE VSP[ECP, "down_cast_float"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FLP00-C. Understand the limitations of floating-point numbers

RULE "51233135" {
    UNSAFE VSP[ECP, "float_equality"]
    OPTION mode = "arith"
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FLP36-C. Preserve precision when converting integral values to
// floating-point type

RULE "51233136" {
    UNSAFE VSP[ECP, "int_to_float"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FLP04-C. Check floating-point inputs for exceptional values

// No CP_RULE exists.
// #include 5111.rdl GROUP FormatInput
// #include 5111.rdl GROUP 51003117 51233129
// #include 5111.rdl RULE 51003117 51233129

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ STR02-CPP. Sanitize data passed to complex subsystems

RULE "51233235" {
    UNSAFE VSP[ECP, "sanitize_data_to_subsystem"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ STR03-CPP. Do not inadvertently truncate a null-terminated
// character array

// TODO: Replace with CSP.
RULE "51233236" {
    // UNSAFE VSP[ECP, "arr_idx_out_simple"]
    // OPTION nonterm = "true"
    // OPTION writer = ["strncpy", "strncat", "fgets", "snprintf"]
    // OPTION pos = "update"
    UNSAFE VSP[ECP, "unit"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ STR04-CPP. Use plain char for characters in the basic character
// set

RULE "51233237" {
    UNSAFE VSP[ECP, "string_assign_to_non_plain_chars"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ STR06-CPP. Do not assume that strtok() leaves the parse string
// unchanged

RULE "51233239" {
    UNSAFE VSP[ECP, "use_of_strtok_chk"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C STR30-C. Do not attempt to modify string literals

RULE "51233241" {
    UNSAFE VSP[ECP, "modify_string_literals"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C STR31-C. Guarantee that storage for strings has sufficient space for
// character data and the null terminator

// TODO: Replace with CSP.
RULE "51233242" {
    // UNSAFE VSP[ECP, "arr_idx_out_simple"]
    // OPTION string = "true"
    // OPTION mode = "write"
    UNSAFE VSP[ECP, "unit"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C STR32-C. Do not pass a non-null-terminated character sequence to a
// library function that expects a string

// TODO: Replace with CSP.
RULE "51233243" {
    // UNSAFE VSP[ECP, "arr_idx_out_simple"]
    // OPTION nonterm = "true"
    // OPTION pos = "update"
    UNSAFE VSP[ECP, "unit"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C STR34-C. Cast characters to unsigned char before converting to
// larger integer sizes

RULE "51233245" {
    UNSAFE VSP[ECP, "char_int_assign_missing_unsigned_cast"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ STR50-CPP. Guarantee that storage for strings has sufficient space
// for character data and the null terminator

RULE "51233246" {
    PATTERN {
        UNSAFE VSP[ECP, "forbidden_fcall"]
        OPTION function = ["gets"]
    }

    PATTERN {
        UNSAFE VSP[ECP, "unbound_scanf"]
    }
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C STR37-C. Arguments to character-handling functions must be
// representable as an unsigned char

RULE "51233248" {
    UNSAFE VSP[ECP, "args_unsigned_char"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ MEM01-CPP. Store a valid value in pointers immediately after
// deallocation

RULE "51233162" {
    UNSAFE VSP[SASP, C, 3131]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ MEM02-CPP. Immediately cast the result of a memory allocation
// function call into a pointer to the allocated type

RULE "51233163" {
    UNSAFE VSP[ECP, "typ_chk_malloc"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ MEM04-CPP. Do not perform zero-length allocations

RULE "51233165" {
    PATTERN {
        UNSAFE VSP[ECP, "validate_param_simple"]
        OPTION function = ["malloc"]
        OPTION arg = 0
        OPTION invalid = 0
    }

    PATTERN {
        UNSAFE VSP[ECP, "validate_param_simple"]
        OPTION function = ["realloc", "calloc"]
        OPTION arg = 1
        OPTION invalid = 0
    }
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ MEM07-CPP. Ensure that the arguments to calloc(), when multiplied,
// can be represented as a size_t

RULE "51233168" {
    UNSAFE VSP[SASP, C, 3133]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ MEM09-CPP. Do not assume memory allocation routines initialize
// memory

RULE "51233169" {
    UNSAFE  [malloc($$):$1] <--if [strncpy($1, $$, $$)]
    EXCLUDE [strncpy($1, $$, $$)] -->if [ASSIGN($1 := $<LIT "0" OR LIT "\0">)]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ MEM11-CPP. Allocate and free memory in the same module, at the
// same level of abstraction

// RULE "?" {
//     UNSAFE VSP[ECP, "malloc_free_other_level"]
// }

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ MEM50-CPP. Do not access freed memory

// DEPRECATED: Use CSP.
RULE "51233173" {
    // UNSAFE VSP[ECP, "dang_deref_simple"]
    // OPTION type = "freed"
    UNSAFE VSP[ECP, "unit"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ MEM51-CPP. Properly deallocate dynamically allocated resources

// DEPRECATED: Use CSP.
RULE "51233174" {
    // UNSAFE VSP[ECP, "double_free_simple"]
    // OPTION type = "freed"
    UNSAFE VSP[ECP, "unit"]
}

// DEPRECATED: Use CSP.
RULE "51233177" {
    // UNSAFE VSP[ECP, "free_nonheap_simple"]
    UNSAFE VSP[ECP, "unit"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ FIO00-CPP. Take care when creating format strings

RULE "51233091" {
    UNSAFE VSP[ECP, "type_variadic_func"]
    OPTION ignore_unknown_type = "false"
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ FIO01-CPP. Be careful using functions that use file names for
// identification

RULE "51233092" {
    UNSAFE [fopen($1, $$)] <--if [/remove\|chown\|stat\|chmod/($1, ...)]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ FIO02-CPP. Canonicalize path names originating from untrusted
// sources

RULE "51233093" {
    UNSAFE  [#External($1)] <--if [fopen($1, $$)]
    EXCLUDE [#External($1)]
      <--if [realpath($1, $<null OR LIT "NULL" OR LIT "0">):$2]
      <--if [fopen($2, $$)]
    EXCLUDE [#External($1)]
      <--if [$2<NAME PATH_MAX>]
      <--if [realpath($1, $2):$3]
      <--if [fopen($3, $$)]
    EXCLUDE [#External($1)]
      <--if [canonicalize_file_name($1):$2]
      <--if [fopen($2, $$)]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ FIO05-CPP. Identify files using multiple file attributes

RULE "51233096" {
    UNSAFE  [/fopen\|open/($1, ...)] <--if [/fopen\|open/($1, ...)]
    EXCLUDE [/fopen\|open/($1, ...):$2]
      <--if [fstat($2, $$)]
      <--if [/fopen\|open/($1, ...)]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ FIO05-CPP. Identify files using multiple file attributes

RULE "51233099" {
    UNSAFE  [fopen($1, ...)] <--if [remove($1)]
    EXCLUDE [fopen($1, ...):$2] <--if [fclose($2)] <--if [remove($1)]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ FIO09-CPP. Be careful with binary data when transferring data
// across systems

RULE "51233100" {
    UNSAFE VSP[ECP, "fread_struct_pointer"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ FIO13-CPP. Never push back anything other than one read character

RULE "51233104" {
    UNSAFE [fopen($$, $$):$1] <--if [ungetc($$, $1)] <--if [ungetc($$, $1)]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO30-C. Exclude user input from format strings

GROUP #"51233109".* = #"51230134".*
RULE "51233109" = "51230134"

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ FIO21-CPP. Do not simultaneously open the same file multiple times

// TODO: Migrate to SASP.
RULE "51233110" {
    UNSAFE VSP[ECP, "unit"]
    // UNSAFE VSP[ECP, "taint_analysis"]
    // OPTION rule = "FIO+31"
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO32-C. Do not perform operations on devices that are only
// appropriate for files

RULE "51233111" {
    UNSAFE VSP[ECP, "lstat_open_fstat"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO34-C. Distinguish between characters read from a file and EOF or
// WEOF

RULE "51233113" {
    UNSAFE VSP[ECP, "char_capture_char_io_fun"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO36-C. Do not assume a new-line character is read when using
// fgets()

RULE "51233115" {
    UNSAFE [fgets($1, ...)] <--rf [strlen($1)]
     <--if [($1, -, $<LIT "1", INT>)]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO37-C. Do not assume that fgets() or fgetws() returns a nonempty
// string when successful

RULE "51233116" {
    UNSAFE VSP[ECP, "assume_ret_nonemp_string_simple"]
    OPTION function = "fgets"
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO38-C. Do not copy a FILE object

RULE "51233117" {
    UNSAFE VSP[ECP, "copy_file_object"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ FIO50-CPP. Do not alternately input and output from a file stream
// without an intervening positioning call

RULE "51233118" {
    PATTERN {
        UNSAFE  [fopen($$, $$):$1] <--if [fwrite(..., $1)] <--if [fread(..., $1)]
        EXCLUDE [fopen($$, $$):$1] <--if [fwrite(..., $1)]
          <--if [/fflush\|fseek\|fsetpos\|rewind/(..., $1, ...)]
          <--if [fread(..., $1)]
    }

    PATTERN {
        UNSAFE  [fopen($$, $$):$1] <--if [fread(..., $1)] <--if [fwrite(..., $1)]
        EXCLUDE [fopen($$, $$):$1] <--if [fread(..., $1)]
          <--if [/fseek\|fsetpos\|rewind/(..., $1, ...)]
          <--if [fwrite(..., $1)]
    }
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO40-C. Reset strings on fgets() or fgetws() failure

RULE "51233119" {
    UNSAFE VSP[ECP, "missing_reset_fgets_failure"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO41-C. Do not call getc(), putc(), getwc(), or putwc() with a
// stream argument that has side effects

RULE "51233120" {
    UNSAFE VSP[ECP, "funparam_sideeffect"]
    OPTION target = "getputc"
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ FIO51-CPP. Close files when they are no longer needed

RULE "51233121" {
    PATTERN {
        UNSAFE  [fopen($$, $$)] -->if [/system\|fork\|exec/(...)]
        EXCLUDE [fopen($$, $$):$1] -->if [fclose($1)]
          -->if [/system\|fork\|exec/(...)]
    }

    PATTERN {
        UNSAFE  [open($$, $$)] -->if [/system\|fork\|exec/(...)]
        EXCLUDE [open($$, $$):$1] -->if [close($1)]
          -->if [/system\|fork\|exec/(...)]
        EXCLUDE [open($$, $$):$1]
          -->if [$2<NAME FD_CLOEXEC>]
          -->if [fcntl($1, $<NAME F_SETFD>, $2)]
          -->if [/system\|fork\|exec/(...)]
        EXCLUDE [$1<NAME O_CLOEXEC>]
          <--if [open($$, $1)]
    }
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C FIO44-C. Only use values for fsetpos() that are returned from
// fgetpos()

RULE "51233123" {
    UNSAFE  [fsetpos($$, $$)]
    EXCLUDE [fgetpos($$, $1)] <--if [fsetpos($$, $1)]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C ENV01-C. Do not make assumptions about the size of an environment
// variable

// TODO: Replace with CSP.
RULE "51233043" {
    // UNSAFE VSP[ECP, "arr_idx_out_simple"]
    // OPTION source = "getenv"
    UNSAFE VSP[ECP, "unit"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C ENV34-C. Do not store pointers returned by certain functions

RULE "51233042" {
    UNSAFE VSP[ECP, "getenv_store"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C ENV31-C. Do not rely on an environment pointer following an
// operation that may invalidate it

RULE "51233048" {
    PATTERN {
        UNSAFE [setenv(...)] <--cf [$<NAME envp>] in FUNCTION<main>
    }
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C ENV32-C. All exit handlers must return normally

RULE "51233049" {
    UNSAFE VSP[ECP, "atexit_abnormal_termination"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ ERR01-CPP. Use ferror() rather than errno to check for FILE stream
// errors

RULE "51233051" {
    UNSAFE VSP[ECP, "stdio_errno"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ ERR06-CPP. Understand the termination behavior of assert() and
// abort()

RULE "51233056" {
    UNSAFE VSP[ECP, "atexit_assert"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ ERR10-CPP. Detect and handle standard library errors

RULE "51233058" {
    PATTERN {
        UNSAFE VSP[SASP, C, 3083]
        OPTION function = [
            "fopen", "gets", "fgets", "aligned_alloc",
            "bsearch", "bsearch_s", "calloc", "freopen",
            "getenv", "getenv_s", "gets_s", "gmtime", "gmtime_s",
            "realloc", "localtime", "localtime_s", "malloc", "memchr",
            "setlocale", "strchr", "strpbrk", "strrchr", "strstr",
            "strtok", "strtok_s", "tmpfile", "tmpnam", "wcschr",
            "wcspbrk", "wcsrchr", "wcsstr", "wcstok", "wcstok_s",
            "wmemchr", "fmemopen", "open_memstream", "posix_memalign",
            "fseek", "snprintf"
        ]
    }

    // p = relloc(p, ...)
    PATTERN {
        UNSAFE VSP[SASP, C, 3864]
    }
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ ERR54-CPP. Catch handlers should order their parameter types from
// most derived to least derived

RULE "51233063" {
    UNSAFE VSP[ECP, "catch_class"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C ERR33-C. Detect and handle standard library errors

// TODO: Replace with CSP.
RULE "51233112" {
    // UNSAFE VSP[ECP, "null_deref_simple"]
    // OPTION generator = ["fopen", "gets", "fgets"]
    UNSAFE VSP[ECP, "unit"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ OOP02-CPP. Do not hide inherited non-virtual member functions

RULE "51233205" {
    UNSAFE VSP[ECP, "override_non_virtual_method"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ OOP52-CPP. Do not delete a polymorphic object without a virtual
// destructor

RULE "51233209" {
    UNSAFE VSP[ECP, "non_virtual_dstrct_polym"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ OOP36-CPP. Do not assume that copy constructor invocations will
// not be elided

// RULE "?" {
//     UNSAFE VSP[ECP, "copy_constr_sideeffect"]
// }

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ CON03-CPP

// RULE "?" {
//     UNSAFE VSP[ECP, "thread_unsafe_without_lock"]
// }

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ VOID CON30-CPP. Ensure all threads exit before exiting main

RULE "51233019" {
    UNSAFE VSP[ECP, "invalid_thread_exit"]
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C++ MSC01-CPP. Strive for logical completeness

RULE "51233183" {
    UNSAFE VSP[ECP, "strange_if_switch"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ MSC05-CPP. Do not manipulate time_t typed values directly

RULE "51233187" {
    UNSAFE VSP[ECP, "direct_time_manipulation"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ MSC06-CPP. Be aware of compiler optimization when dealing with
// sensitive data

RULE "51233188" {
    UNSAFE VSP[ECP, "memset_optimize"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ MSC07-CPP. Detect and remove dead code

RULE "51233189" {
    UNSAFE VSP[ECP, "dead_code_simple"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ MSC09-CPP. Character Encoding - Use Subset of ASCII for Safety

RULE "51233191" {
    UNSAFE VSP[ECP, "fopen_name"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ MSC11-CPP. Incorporate diagnostic tests using assertions

RULE "51233193" {
    UNSAFE VSP[ECP, "malloc_assert"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ MSC13-CPP. Detect and remove unused values

RULE "51233195" {
    UNSAFE VSP[SASP, C, 563]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ MSC21-CPP. Use inequality to terminate a loop whose counter
// changes by more than one

RULE "51233201" {
    UNSAFE VSP[ECP, "not_robust_loop"]
    OPTION mode = "simple"
}

//////////////////////////////////////////////////////////////////////////////
// CERT-C MSC31-C. Ensure that return values are compared against the proper
// type

RULE "51233203" {
    UNSAFE VSP[SASP, C, 3041]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ MSC51-CPP. Ensure your random number generator is properly seeded

RULE "51233204" {
    UNSAFE VSP[ECP, "rand_srand"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ SIG00-CPP. Mask signals handled by noninterruptible signal handlers

RULE "51233226" {
    UNSAFE VSP[ECP, "handlers_multi"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ SIG01-CPP. Understand implementation-specific details regarding
// signal handler persistence

RULE "51233227" {
    UNSAFE VSP[ECP, "signal_handler"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ SIG30-C. Call only asynchronous-safe functions within signal
// handlers

RULE "51233229" {
    UNSAFE VSP[ECP, "signal_handlers_functions"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C SIG31-C. Do not access shared objects in signal handlers

RULE "51233230" {
    UNSAFE VSP[ECP, "global_in_handlers"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C SIG34-C. Do not call signal() from within interruptible signal
// handlers

RULE "51233232" {
    UNSAFE VSP[ECP, "signal_in_handler"]
}


//////////////////////////////////////////////////////////////////////////////
// CERT-C++ CTR54-CPP. Do not subtract iterators that do not refer to the same
// container

RULE "51233009" {
    UNSAFE VSP[ECP, "arr_ptr_arith_simple"]
}


//////////////////////////////////////////////////////////////////////////////
// HICPP 3.1.8. Declare 'const' any class member function that does not modify
// the externally visible state of the object

RULE "51233958" {
    UNSAFE VSP[ECP, "func_const"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 3.3.2. Write a 'virtual' destructor for base classes.

RULE "51233922" {
    UNSAFE VSP[ECP, "non_virtual_dstrct_polym"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 3.3.3. Avoid downcasting base class object pointers to derived class.

RULE "51233923" {
    UNSAFE VSP[ECP, "base_derived_casting_func"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 3.3.4. Avoid casting to a virtual base class as this is irreversible.

RULE "51233924" {
    UNSAFE VSP[ECP, "casting_to_base_class"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 3.3.5. Override all overloads of a base class virtual function.

RULE "51233925" {
    UNSAFE VSP[ECP, "override_vitual"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP .3.6. If a virtual function in a base class is not overridden in any
// derived class then make it non virtual.

RULE "51233926" {
    UNSAFE VSP[ECP, "override_vitual_base"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 3.3.9. If a virtual function is overridden in each derived class with
// the same implementation then make it a non virtual function in the base
// class.

RULE "51233927" {
    UNSAFE VSP[ECP, "same_vfunc_impl"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 3.3.10. Ensure that the return type of the virtual function being
// overridden is compatible.

RULE "51233917" {
    UNSAFE VSP[ECP, "override_return_type"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 3.3.11. Do not overload or hide inherited non-virtual functions.

RULE "51233918" {
    UNSAFE VSP[ECP, "override_non_virtual_method"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 3.3.12. When redeclaring and overriding functions use the same
// default parameter values as in other declarations.

RULE "51233919" {
    UNSAFE VSP[ECP, "default_parameter"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 3.3.14. Declare the copy assignment operator protected in an abstract
// class.

RULE "51233920" {
    UNSAFE VSP[ECP, "copy_assignment"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 3.3.15. Ensure base classes common to more than one derived class are
// virtual.

RULE "51233921" {
    UNSAFE VSP[ECP, "diamond_virtual"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 3.3.16. Explicitly declare polymorphic member functions virtual in a
// derived class.

RULE "51233933" {
    UNSAFE VSP[ECP, "override_vitual_explicit"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 3.4.2. Do not return non-const handles to class data from const
// member functions.

RULE "51233959" {
    UNSAFE VSP[ECP, "const_function"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 3.4.3. Do not write member functions which return non const pointers
// or references to data less accessible than the member function.

RULE "51233960" {
    UNSAFE VSP[ECP, "return_nonconst_ptr"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 3.4.5. When publicly deriving from a base class, the base class
// should be abstract.

RULE "51233928" {
    UNSAFE VSP[ECP, "base_class_abstract"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 3.4.6. Write derived classes to have at most one base class which is
// not a pure abstract class.

RULE "51233929" {
    UNSAFE VSP[ECP, "pure_abstract"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 3.5.1. Avoid overloading the comma operator (','), operator AND
// ('&&'), and operator OR ('||').

RULE "51233930" {
    UNSAFE VSP[ECP, "operator_overloading"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 4.1. Do not write functions with an excessive McCabe Cyclomatic
// Complexity.

RULE "51233961" {
    UNSAFE VSP[ECP, "too_many_branch_chk"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 4.2. Avoid functions with a high static program path count.

RULE "51233962" {
    UNSAFE VSP[ECP, "static_path_count"]
    OPTION limit = 200
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 5.12. Declare for loop control variables within the for statement
// instead of using an existing variable.

RULE "51233963" {
    UNSAFE VSP[ECP, "for_control"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 5.2. For boolean expressions ('if', 'for', 'while', 'do' and the
// first operand of the ternary operator '?:') involving non-boolean values,
// always use an explicit test of equality or non-equality.

RULE "51233932" {
    UNSAFE VSP[ECP, "explicit_test"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 5.3. Avoid conditional expressions that always have the same result.

RULE "51233964" {
    UNSAFE VSP[ECP, "unsigned_lit"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 5.5. Do not alter a control variable in the body of a for statement.

RULE "51233965" {
    UNSAFE VSP[ECP, "reuse_of_control_var"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 5.6. Do not alter a control variable more than once in a for, do or
// while statement.

RULE "51233966" {
    UNSAFE VSP[ECP, "reuse_of_control_var"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 5.10. For functions with non-void return type, ensure all paths have
// a return statement that contains an expression of the return type.

RULE "51233931" {
    UNSAFE VSP[ECP, "nonvoid_return_type"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 7.3. Avoid casting away volatile qualification.

RULE "51233935" {
    UNSAFE VSP[ECP, "volatile_casting"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 7.5. Avoid using pointer or reference casts.

RULE "51233937" {
    UNSAFE VSP[ECP, "cast_pointer"]
    OPTION mode = "basic"
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 7.6. Do not convert floating values to integral types except through
// use of standard library routines.

RULE "51233938" {
    UNSAFE VSP[ECP, "explicit_typ_conversion"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 7.7. Do not cast pointers to and from fundamental types.

RULE "51233939" {
    UNSAFE VSP[ECP, "type_casting"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 7.8. Do not write code that relies on implicit conversions of
// arguments in function calls.

RULE "51233940" {
    UNSAFE VSP[ECP, "implicit_typ_conversion"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 8.3.2. Restrict the use of the 'extern' keyword. Do not write
// 'extern' where it is implicit.

RULE "51233967" {
    UNSAFE VSP[ECP, "extern_function"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 8.4.3. Initialise all objects at definition. Never use an object
// before it has been given a value.

RULE "51233969" {
    UNSAFE VSP[ECP, "initial_value"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 8.4.4. Postpone variable definitions as long as possible.

RULE "51233970" {
    UNSAFE VSP[ECP, "var_def"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 8.4.5. Do not use the plain 'char' type when declaring objects that
// are subject to numeric operations. In this case always use an explicit
// 'signed char' or 'unsigned char' declaration.

RULE "51233943" {
    UNSAFE VSP[ECP, "numeric_char"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 8.4.10. Avoid pointers to members.

RULE "51233941" {
    UNSAFE VSP[ECP, "member_pointer"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 8.4.11. Use 'const' whenever possible.

RULE "51233968" {
    PATTERN { UNSAFE VSP[ECP, "const_method"] }
    PATTERN { UNSAFE VSP[ECP, "const_var"] }
    PATTERN { UNSAFE VSP[ECP, "const_param"] OPTION dest = "general" }
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 8.4.13. Prefer to use signed numeric values, not unsigned.

RULE "51233942" {
    UNSAFE VSP[ECP, "implicit_typ_conversion"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 9.2. Only throw objects of class type.

RULE "51233944" {
    UNSAFE VSP[ECP, "throwable_classtype"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 10.2. Access to an array should be demonstrably within the bounds of
// the array.

// DEPRECATED: Use CSP.
RULE "51233949" {
    PATTERN {
        // UNSAFE VSP[ECP, "arr_idx_out_simple"]
        UNSAFE VSP[ECP, "unit"]
    }
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 10.3. Do not assume the order of evaluation of operands in an
// expression.

RULE "51233950" {
    UNSAFE VSP[ECP, "double_sideeffect_exp_fast"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 10.7. Do not use expressions which rely on implicit conversion of an
// operand.

RULE "51233907" {
    UNSAFE VSP[ECP, "implicit_typ_conversion"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 10.8. Ensure expressions used in assertions are free from
// side-effects.

RULE "51233951" {
    UNSAFE VSP[ECP, "funparam_sideeffect"]
    OPTION mode = "fast"
    OPTION target = "assert"
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 10.9. Do not code side effects into the right-hand operands of '&&',
// '||', 'sizeof' or 'typeid'.

RULE "51233952" {
    UNSAFE VSP[ECP, "operand_sideeffect"]
    OPTION mode = "fast"
    OPTION rule = "HICPP"
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 10.10. Avoid statements that have no side effects.

RULE "51233945" {
    UNSAFE VSP[ECP, "non_null_statement"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 10.11. Do not apply the following bitwise operators to signed
// operands: shift operators ('<<', '>>'), bitwise AND ('&'), exclusive OR
// ('^') and inclusive OR ('|').

RULE "51233901" {
    UNSAFE VSP[ECP, "only_uint_bitwise"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 10.12. Validate arguments to be used in shift operators.

RULE "51233946" {
    UNSAFE VSP[ECP, "shift_simple"]
    OPTION inclusive = "true" // TODO
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 10.13. Do not mix signed and unsigned data items in the same
// expression.

RULE "51233902" {
    UNSAFE VSP[ECP, "implicit_typ_conversion"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 10.14. Do not mix arithmetic precision in expressions.

RULE "51233903" {
    UNSAFE VSP[ECP, "arithmetic_float"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 10.15. Do not write code that expects floating point calculations to
// yield exact results.

// FIXME: Duplicated to 51233127
RULE "51233904" {
    UNSAFE VSP[ECP, "float_equality"]
    OPTION mode = "general"
}


//////////////////////////////////////////////////////////////////////////////
// HICPP 10.16. Do not use the increment operator ('++') on a variable of type
// 'bool'.

RULE "51233905" {
    UNSAFE VSP[ECP, "bool_preincr"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 10.18. Guard the modulus operation to ensure that both arguments are
// non-negative.

RULE "51233948" {
    UNSAFE VSP[ECP, "negative_in_mod_simple"]
    OPTION hotspot = "operand"
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 10.21. Apply unary minus to operands of signed type only.

RULE "51233906" {
    UNSAFE VSP[ECP, "uminus_unsigned"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 11.5. Declare read-only parameters of class type as const
// references. Pass by value read-only parameters that are of a fundamental
// type.

RULE "51233953" {
    UNSAFE VSP[ECP, "const_param"]
    OPTION mode = "fast"
    OPTION dest = "hicpp11.5"
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 11.7. A function should not return a reference or a pointer to an
// automatic variable defined within the function. Instead, it should return a
// copy of the object.

RULE "51233954" {
    UNSAFE VSP[ECP, "return_ptr_of_auto"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 12.5. Do not return a dereferenced pointer initialised by dynamic
// allocation within a function.

// FIXME: Duplicated.
RULE "51233955" = "51233859"

//////////////////////////////////////////////////////////////////////////////
// HICPP 12.8. On use of delete always set the pointer to zero after the
// delete.

// TODO: Migrate to SASP. [SASP, C, 3131], but should consider `delete`.
RULE "51233956" {
    UNSAFE VSP[ECP, "unit"]
    // UNSAFE VSP[ECP, "dealloc_missing_assign"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 13.7. Do not cast a pointer to fundamental type, to a pointer to a
// more restrictively aligned fundamental type.

RULE "51233908" {
    UNSAFE VSP[ECP, "cast_pointer"]
    OPTION mode = "basic+"
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 15.3. Do not rely on the value of an enumerator.

RULE "51233909" {
    UNSAFE VSP[ECP, "enum_value"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 15.4. Avoid casting an integer to an enumeration as the result of
// this cast is unspecified if the value is not within the range of the
// enumeration.

RULE "51233957" {
    UNSAFE VSP[ECP, "cast_to_enum"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 16.1. Avoid implicit conversions from class templates to non-
// dependent types as this ensures that clients cannot bypass the class
// interface.

RULE "51233910" {
    UNSAFE VSP[ECP, "operator_template"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 16.4. Only use templates when the behaviour of the class or function
// template is completely independent of the type of object to which it is
// applied.

RULE "51233911" {
    UNSAFE VSP[ECP, "casting_template"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 17.16. Minimise mixing of iterator types.

RULE "51233912" {
    UNSAFE VSP[ECP, "mix_iterator"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 17.17. The result of a predicate should depend only on its parameters.

RULE "51233913" {
    UNSAFE VSP[ECP, "dynamic_field"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 17.4. Where copying is expensive use containers of pointers or smart
// pointers.

RULE "51233915" {
    UNSAFE VSP[ECP, "copy_class_data"]
    OPTION limit = 6
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 17.5. Do not attempt to insert derived class objects in a container
// that holds base class objects.

RULE "51233916" {
    UNSAFE VSP[ECP, "copy_class_derived"]
}

//////////////////////////////////////////////////////////////////////////////
// HICPP 17.19. Use container member functions rather than algorithms with the
// same name.

RULE "51233914" {
    UNSAFE VSP[ECP, "set_iterator"]
}

//////////////////////////////////////////////////////////////////////////////
// MISRA C++ 5-0-11: The plain char type shall only be used for the storage
// and use of character values.

// RULE "?" {
//     UNSAFE VSP[ECP, "char_nonplain_char_assign"]
// }

//////////////////////////////////////////////////////////////////////////////
// MISRA C++ 5-0-12: signed char and unsigned char type shall only be used for
// the storage and use of numeric values.

// RULE "?" {
//     UNSAFE VSP[ECP, "char_nonplain_char_assign"]
// }

//////////////////////////////////////////////////////////////////////////////
// MISRA C++ 5-14-1: The right-hand operand of a logical && or || operator
// shall not contain side effects.

// RULE "?" {
//     UNSAFE VSP[ECP, "logical_op_sideeffect"]
//     OPTION mode = "fast"
// }

// DEPRECATED
RULE "51233999" {
    UNSAFE VSP[ECP, "unit"]
}

// DEPRECATED: Use CSP.
RULE "51233524" {
    // UNSAFE VSP[ECP, "access_to_uninit_simple"]
    UNSAFE VSP[ECP, "unit"]
}



// TEST-CONFIG: product=beSOURCE

// Local variables:
// compile-command: "make all rdl && rdl --lint 5123.rdl"
// End:
